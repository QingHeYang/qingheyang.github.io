<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深度集成使用高德地图功能--猎鹰（1） 记录轨迹篇]]></title>
    <url>%2Farchives%2F1ca89d06.html</url>
    <content type="text"><![CDATA[本文适用对象：已继承了猎鹰功能的朋友及使用期间遇到困难的朋友。 背景前段日子公司要求上线一个功能，具有导航，记录轨迹，查看历史行程等功能的一个模块，我用过百度地图，但是公司继承的是高德地图，索性直接用高德，其实我对百度观感也极差，理由就是–作恶多端。功能是要做的，时间也很急，12月上旬左右说的需求，还没有UI图，要求年底前上线，我们大概7个移动端开发人员，全都上了，我主要负责的就是记点，记轨迹，查轨迹的功能，其中遇到了很多很多坑，也算是一种提升吧。 过程&amp;难点过程技术选型预研阶段，与后台考虑过是否自己上传点位，报告位置，一开始是这么选的，后来感觉对于流量还有并发等问题，也是碰巧遇到了高德的猎鹰，研究了下，就直接用人家的接口了，总比花自己的流量要实惠。于是乎我就负责了猎鹰的继承，然后还要帮助同事写一点接口，本文没有关于视图层的东西。 难点遇到了挺多的难点，其实继承第三方并不困难，困难的就在于，第三方有可能文档不全，这是个问题。我在期间遇到了挺多难题，总结一下吧。记录轨迹的难题有： 记录点位不全 内存泄漏的问题 8.0以上系统后台定位被限制住 闲话不多说，直接上代码。 实现依赖1234implementation 'com.amap.api:navi-3dmap:latest.integration'implementation 'com.amap.api:search:latest.integration'implementation 'org.greenrobot:eventbus:3.1.1'implementation files('libs/AMapTrack_1.1.0_AMapLocation_4.8.0_20191210.jar') 继承猎鹰功能必须用jar包形式， jar包里面顺道包含了定位的sdk，所以不用在二次依赖定位的sdk ，不然会报错。信息传递使用的是EventBus。 实体类实体类如下，用于被EventBus传递信息。12345678910111213141516171819202122232425262728293031323334353637383940414243public class TrackInfo &#123; private long terminalId; private long trackId; private String message; private boolean canUse; public boolean isCanUse() &#123; return canUse; &#125; public void setCanUse(boolean canUse) &#123; this.canUse = canUse; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public long getTerminalId() &#123; return terminalId; &#125; public void setTerminalId(long terminalId) &#123; this.terminalId = terminalId; &#125; public long getTrackId() &#123; return trackId; &#125; public void setTrackId(long trackId) &#123; this.trackId = trackId; &#125;&#125; 轨迹服务官方已经给了启动顺序，我简化了下，根据他的demo也改了下，启动顺序是这样的： 新建TerminalId,使用QueryTerminalRequest，传入serviceId、terminalName，如果得到terminalId不为0，去往第3步；为0，去第2步。 因为terminalId=0，所以是一个新的设备，调用AddTerminalRequest，传入serviceId、terminalName，得到terminalId。 根据上一步的回调得到terminalId，调用AddTrackRequest，传入serviceId、terminalId，得到trackId。 三个id都得到后，可以根据官方api，调用 client.startTrack（）方法，启动轨迹。 启动轨迹后，在成功的回调里，调用client.startGather（）方法，启动收集点位。 几步代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 创建路线 * * @param serviceId * @param terminalName * @param trackId */ public void createTrack(final long serviceId, final String terminalName, final long trackId) &#123; this.serviceId = serviceId; this.trackId = trackId; client.queryTerminal(new QueryTerminalRequest(serviceId, terminalName), new SimpleOnTrackListener() &#123; @Override public void onQueryTerminalCallback(QueryTerminalResponse queryTerminalResponse) &#123; if (queryTerminalResponse.isSuccess()) &#123; if (queryTerminalResponse.getTid() &lt;= 0) &#123;//新用户去申请terminalId addTerminal(serviceId, terminalName, trackId); &#125; else &#123; long terminalId = queryTerminalResponse.getTid();//老用户直接获取terminalId if (trackId != 0) &#123;//此处为断点续传//如果有trackId，则直接返回成功，去startGather if (trackDoSthListener != null) &#123; trackDoSthListener.onCreateTrackSuccess(serviceId, terminalId, trackId); &#125; else &#123; onTrackListenerNull(); &#125; &#125; else &#123;//为0为新的 createTrack(serviceId, terminalId); &#125; &#125; &#125; else &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onDoingFailed(queryTerminalResponse.getErrorMsg(), queryTerminalResponse.getErrorCode(), "查询Terminal"); &#125; else &#123; onTrackListenerNull(); &#125; &#125; &#125; &#125;); &#125; /** * 新建terminal * @param serviceId * @param terminalName * @param trackId */ private void addTerminal(final long serviceId, String terminalName, final long trackId) &#123; client.addTerminal(new AddTerminalRequest(terminalName, serviceId), new SimpleOnTrackListener() &#123; @Override public void onCreateTerminalCallback(AddTerminalResponse addTerminalResponse) &#123; if (addTerminalResponse.isSuccess()) &#123; long terminalId = addTerminalResponse.getTid(); TrackFactory.this.terminalId = terminalId; if (trackId != 0) &#123; trackDoSthListener.onCreateTrackSuccess(serviceId, terminalId, trackId); &#125; else &#123; createTrack(serviceId, terminalId); &#125; &#125; else &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onDoingFailed(addTerminalResponse.getErrorMsg(), addTerminalResponse.getErrorCode(), "新建Terminal"); &#125; else &#123; onTrackListenerNull(); &#125; &#125; &#125; &#125;); &#125; /** * 重写方法 * * @param serviceId * @param terminalId */ private void createTrack(final long serviceId, final long terminalId) &#123; this.terminalId = terminalId; client.addTrack(new AddTrackRequest(serviceId, terminalId), new SimpleOnTrackListener() &#123; @Override public void onAddTrackCallback(AddTrackResponse addTrackResponse) &#123; if (addTrackResponse.isSuccess()) &#123; trackId = addTrackResponse.getTrid(); if (trackDoSthListener != null) &#123; trackDoSthListener.onCreateTrackSuccess(serviceId, terminalId, trackId); &#125;else &#123; onTrackListenerNull(); &#125; &#125; else &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onDoingFailed(addTrackResponse.getErrorMsg(), addTrackResponse.getErrorCode(), "新建Track"); &#125;else &#123; onTrackListenerNull(); &#125; &#125; &#125; &#125;); &#125; 如果收集完毕，轨迹停止顺序为下： 调用官方api，client.stopGather()，停止收集点位。 得到停止收集点位成功的回调里，调用client.stopTrack()，停止定位服务。 值得注意的是，开始的时候是先启动track，在启动gather。而停止的时候正好是反着的，先停止gather，在停止track，不要搞反。 三个Id分别为：serviceId,terminalId,trackId，是核心的东西，需要传给后台服务器，供以后查询使用。猎鹰生命周期如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 启动猎鹰生命周期回调 */ private void newListener() &#123; listener = new OnTrackLifecycleListener() &#123; @Override public void onBindServiceCallback(int i, String s) &#123; &#125; @Override public void onStartGatherCallback(int i, String s) &#123; if (i == ErrorCode.TrackListen.START_GATHER_SUCEE || i == ErrorCode.TrackListen.START_GATHER_ALREADY_STARTED) &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onStartSuccess(serviceId, terminalId, trackId); &#125; else &#123; onTrackListenerNull(); &#125; &#125; else &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onDoingFailed(s, 0, "定位开始收集失败"); &#125; else &#123; onTrackListenerNull(); &#125; &#125; &#125; @Override public void onStartTrackCallback(int i, String s) &#123; if (i == ErrorCode.TrackListen.START_TRACK_SUCEE || i == ErrorCode.TrackListen.START_TRACK_SUCEE_NO_NETWORK || i == ErrorCode.TrackListen.START_TRACK_ALREADY_STARTED) &#123; // 服务启动成功，继续开启收集上报 client.startGather(this); //ToastUtil.getInstance()._short(context, "开始路程成功"); &#125; else &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onDoingFailed(s, 0, "Track服务启动失败"); &#125; else &#123; onTrackListenerNull(); &#125; &#125; &#125; @Override public void onStopGatherCallback(int i, String s) &#123; if (i == ErrorCode.TrackListen.STOP_GATHER_SUCCE) &#123; TrackParam tp = new TrackParam(serviceId, terminalId); client.stopTrack(tp, listener); &#125; else &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onDoingFailed(s, i, "定位停止采集失败"); &#125; else &#123; onTrackListenerNull(); &#125; &#125; &#125; @Override public void onStopTrackCallback(int i, String s) &#123; if (i == ErrorCode.TrackListen.STOP_TRACK_SUCCE) &#123; // 成功停止 if (trackDoSthListener != null) &#123; trackDoSthListener.onStopSuccess(); &#125; else &#123; onTrackListenerNull(); &#125; &#125; else &#123; if (trackDoSthListener != null) &#123; trackDoSthListener.onDoingFailed(s, i, "路程停止失败"); &#125; else &#123; onTrackListenerNull(); &#125; &#125; &#125; &#125;; &#125; 上面大概就是猎鹰功能的核心代码，很多都没写全，本想着开一篇就够了，但是感觉篇幅太长，就算了。 前台服务猎鹰功能本身是自己带着service的，但是如果一直处在后台状态，会被杀死，尤其是Android 8.0以后，限制住了很多权限，其中就有后台定位功能。猎鹰推荐8.0系统启动一个 ForcegroundService，新出的前台进程，也可以给他们的api传一个notification，让他们自己启动前台进程，但是有一个问题，就是他们的接口已经过时了，不能用了，于是我研究了下，就自己写了一个前台Service来确保猎鹰可以正常取点。我在其中做了个media Player来确保尽可能不被后台杀死。在单例里面用四大组件的上下文一定要特别注意，最好传getApplicationContext()，因为Application的上下文是能贯穿整个app的，我一开始因为失误，再单例里面传了Service的上下文，导致service一直无法被回收，导致内存泄漏。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/* * ************************************************************ * 文件：CarManageService.java 模块：app 项目：oemp-android * 当前修改时间：2019年12月25日 09:57:10 * 上次修改时间：2019年12月25日 09:57:10 * 作者：QingHeyang * QingHeyang版权所有 * ************************************************************ */package com.qhy.trackdemo.service;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.drawable.BitmapDrawable;import android.media.MediaPlayer;import android.os.Build;import android.os.IBinder;import com.qhy.trackdemo.MainActivity;import com.qhy.trackdemo.R;import org.greenrobot.eventbus.EventBus;public class TrackDemoService extends Service &#123; private static final String CHANNEL_ID_SERVICE_RUNNING = "CHANNEL_ID_SERVICE_RUNNING"; private long serviceId; private long terminalId, trackId; private String terminalName; private Notification notification; private MediaPlayer bgmediaPlayer; private Intent intent; @Override public void onCreate() &#123; super.onCreate(); Notification notification = registerNotification(); this.notification = notification; // BaseApplication.getRefWatcher().watch(this); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if (intent != null &amp;&amp; this.intent == null) &#123; this.intent = intent; startGather(intent); &#125; return START_REDELIVER_INTENT; &#125; /** * 注册用于8.0以后的手机 * * @return */ private Notification registerNotification() &#123; Notification.Builder builder; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; NotificationManager nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); NotificationChannel channel = new NotificationChannel(CHANNEL_ID_SERVICE_RUNNING , "猎鹰服务" , NotificationManager.IMPORTANCE_LOW); nm.createNotificationChannel(channel); builder = new Notification.Builder(this, CHANNEL_ID_SERVICE_RUNNING); &#125; else &#123; builder = new Notification.Builder(this); &#125; Intent nfIntent = new Intent(this, MainActivity.class);//此处的Activity为前台进程的Notification点击回调页面 nfIntent.putExtra("fromService", true); Bitmap bitmap = ((BitmapDrawable) getResources().getDrawable(R.mipmap.ic_launcher)).getBitmap();//此处icon需要根据自己需求来 builder.setContentIntent(PendingIntent.getActivity(this, 0, nfIntent, PendingIntent.FLAG_UPDATE_CURRENT)) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(bitmap) .setContentTitle("您的有未完成的行程进行中...") .setContentText("点击回到行程"); Notification notification = builder.build(); return notification; &#125; /** * 开始收集 * * @param intent */ public void startGather(Intent intent) &#123; terminalName = intent.getStringExtra("terminalName"); trackId = intent.getLongExtra("trackId", 0); serviceId = intent.getLongExtra("serviceId", 0); /*Notification notification = registerNotification(); startForeground((int) System.currentTimeMillis(),notification);*/ TrackFactory.getInstance(getApplicationContext()).setOnTrackDoSthListener(new TrackFactory.OnTrackDoSthListener() &#123; @Override public void onCreateTrackSuccess(long serviceId, long terminalId, long trackId) &#123; TrackDemoService.this.terminalId = terminalId; TrackDemoService.this.trackId = trackId; TrackFactory.getInstance(TrackDemoService.this.getApplicationContext()).startGather(serviceId, terminalId, trackId); &#125; @Override public void onStartSuccess(long serviceId, long terminalId, long trackId) &#123; TrackInfo info = new TrackInfo(); info.setTrackId(trackId); info.setTerminalId(terminalId); info.setCanUse(true); EventBus.getDefault().post(info); startForeground((int) System.currentTimeMillis(), notification); &#125; @Override public void onStopSuccess() &#123; &#125; @Override public void onDoingFailed(String msg, long code, String from) &#123; TrackInfo info = new TrackInfo(); info.setMessage(msg + "\n" + from); info.setCanUse(false); EventBus.getDefault().post(info); &#125; &#125;); TrackFactory.getInstance(getApplicationContext()).createTrack(serviceId, terminalName, trackId); playMusic(); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; /** * 此处播放无声音乐，用来不被系统杀死 */ private void playMusic() &#123; if (bgmediaPlayer == null) &#123; bgmediaPlayer = MediaPlayer.create(this, 0); bgmediaPlayer.start(); bgmediaPlayer.setLooping(true); bgmediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; bgmediaPlayer.start(); bgmediaPlayer.setLooping(true); &#125; &#125;); &#125; &#125; @Override public void onDestroy() &#123; if (bgmediaPlayer != null) &#123; bgmediaPlayer.stop(); bgmediaPlayer = null; &#125; TrackFactory.getInstance(getApplicationContext()).stopGather(serviceId, terminalId); TrackDemoService.this.stopForeground(true); super.onDestroy(); &#125;&#125; 电池白名单还有一个问题就是，在8.0以后，存在了电池白名单的问题，如果不申请，后台会被限制活动，这里给出方法：1234567891011121314151617181920212223242526272829303132/** * 判断用户是否在电池白名单 * * @param context * @return */@RequiresApi(api = Build.VERSION_CODES.M)public static boolean inWhiteList(Context context) &#123; boolean isIgnoring = false; PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); if (powerManager != null) &#123; isIgnoring = powerManager.isIgnoringBatteryOptimizations(context.getPackageName()); &#125; return isIgnoring;&#125;/** * 请求电池白名单 * @param context * @return */public static Intent doRequestWhiteList(Context context) &#123; Intent intent = new Intent(); try &#123; String packageName = context.getPackageName(); intent.setAction(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS); intent.setData(Uri.parse("package:" + packageName)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return intent;&#125; 启动服务回头再写…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>高德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档(Personal Used)]]></title>
    <url>%2Farchives%2Fabbd6e6.html</url>
    <content type="text"><![CDATA[日历页：http://xxxx.xxx.xx:/WeekStory/queryMonth.do?from=1&amp;date=2019-12-01 (Get)返回结果：123456&#123; "msg":"success", "monthInfo":[ 2019-12-21 ]&#125; 点击日期检查是否有文件http://xxxx.xxx.xx:/WeekStory/doSomethingCheck.do?from=1&amp;date=2019-12-21 (Get)返回结果：1234&#123; "msg":"file exist", "code":200&#125; 点击创建文件http://xxxx.xxx.xx:/WeekStory/doSomethingCreate.do?from=1&amp;date=2019-12-21 (Get)返回结果：1&#123;"msg":"1-20191216-20191222.xls","code":200&#125; 进入页面提交所写内容http://xxxx.xxx.xx:/WeekStory/doSomethingSubmit.do (post)参数：12345678910111213&#123; "workStr1":"测试工作1", "workStr2":"测试工作2", "workStr3":"测试工作3", "lifeStr1":"测试生活1", "lifeStr2":"测试生活2", "lifeStr3":"测试生活3", "bzStr":"暂无备注", "sleepTime":"07:00", "weakTime":"23:00", "curDate":"2019-12-21", "user":1&#125; 查询已有的某天http://xxxx.xxx.xx:/WeekStory/doSomethingQueryDay.do?from=1&amp;date=2019-12-21 (Get)返回结果： { "workStr1": "测试工作1", "workStr2": "测试工作2", "workStr3": "测试工作3", "lifeStr1": "测试生活1", "lifeStr2": "测试生活2", "lifeStr3": "测试生活3", "bzStr": "暂无备注", "sleepTime": "07:00", "weakTime": "23:00", "dayOfWeek": 0, "user": 0 } 说明这些接口均为个人项目接口，待前端来校验。说明写于：2020-01-06]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android深入之路:AOP切面编程]]></title>
    <url>%2Farchives%2Fdb153085.html</url>
    <content type="text"><![CDATA[背景这次研究aop其实没有什么背景的，就是觉得到新公司，做项目，应该带有一些跟以前项目不一样的技术，二来我也是喜欢各种技术的，这回没有带着需求，就直接来做一个demo了。 类型想了很久还是没有着手，老实说aop的东西我已经弄好了，感觉应用场景特别大，想想怎么配合吧。更新于：2020-01-06]]></content>
  </entry>
  <entry>
    <title><![CDATA[记一次HLS视频加解密方案的过程（2）]]></title>
    <url>%2Farchives%2F88e27efc.html</url>
    <content type="text"><![CDATA[写在前面上个月花了点时间做了下视频流媒体的方案。传送门:记一次HLS视频加解密方案的过程（1）最后实现的效果是用自己的播放器播放了hls视频流，且视频都加过密了，形成一整套基础的方案。这次呢，出了个方案的升级版，因为使用场景的限制，导致公司必须要对hls视频流进行二次加密。 过程我在网上查了很久，google关于key加密的文章已经读到20页+了。最后只查到了jwplayer这个国外的公司有一种方案，就是对m3u8这个索引文件的AES-128这个字段的获取上面加token，让key文件获取的不是那么容易，但是具体实现还是没有给出来，给出来的android demo也是各种错误，跑不起来。我想各个大厂对自己的hls视频流一定有自己的二次加密的方式，因为我在试用保利威视的sdk的时候，下载了人家的完整的加密视频，但是我没有办法用自己的播放器播出来，所以，肯定做了二次加密的文章。 方案跟上回一样先说一下方案，简单的说，就是对key文件的获取上面进行操作。首先要明白几个道理： 就是播放器读的是m3u8文件，所以操作m3u8文件，就是操作了播放器。 播放器读m3u8内部信息，最后所发出的请求，全部是GET请求，不争的事实。 明白这两点，思路就出来了： 在服务器中保存的m3u8文件要进行错误混淆。 在移动端开启http服务器。 下载服务器m3u8文件，并进行改写。 播放本地服务器中m3u8文件，至播放完毕。 删除改写过后的m3u8文件，并关闭http服务器。 步骤大致就是上述那样了，具体说明一下。 m3u8修改混淆看一个普通的m3u8文件的构造:1234567891011#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:20#EXT-X-MEDIA-SEQUENCE:0#EXT-X-PLAYLIST-TYPE:VOD#EXT-X-KEY:METHOD=AES-128,URI=&quot;http://test.com/enc.key&quot;,IV=0xc25a7ccb63553b6be3f72a89b50d4dd0#EXTINF:15.840000,Y29_050102_VD_04_0_ts#EXTINF:16.720000,Y29_050102_VD_04_1_ts#EXT-X-ENDLIST 加入错误混淆后，去掉URI节点的key，并且保存在服务器中：1234567891011#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:20#EXT-X-MEDIA-SEQUENCE:0#EXT-X-PLAYLIST-TYPE:VOD#EXT-X-KEY:METHOD=AES-128,URI=&quot;&quot;,IV=0xc25a7ccb63553b6be3f72a89b50d4dd0#EXTINF:15.840000,Y29_050102_VD_04_0_ts#EXTINF:16.720000,Y29_050102_VD_04_1_ts#EXT-X-ENDLIST 这样，在m3u8中就不存在被别人获取到key的问题了。 Android开启Http服务器我用的是nanoHttp，比较好用。首先写个类集成NanoHTTPD，作为服务调度类。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package sohero.com.testhlsvideo.video;import ...;/** * 项目名称:sohero.com.testhlsvideo.video * 类创建者:QHY. * 时间:2019/4/29 * 类说明:开启httpServer，获取文件类 */public class HlsHttpServer extends NanoHTTPD &#123; public HlsHttpServer(String hostname, int port) &#123; super(hostname, port); &#125; public HlsHttpServer(int port) &#123; super(port); &#125; @Override public Response serve(IHTTPSession session) &#123; try &#123; session.parseBody(new HashMap&lt;String, String&gt;()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ResponseException e) &#123; e.printStackTrace(); &#125; MyApplication app = new MyApplication(); String path = Environment.getExternalStorageDirectory().getPath() + "/HlsTemp/";//获取文件夹地址 Log.i(TAG, "uri: " + path); FileInputStream fis = null; try &#123; fis = new FileInputStream(path + session.getUri()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; return Response.newFixedLengthResponse(Status.OK, "application/octet-stream", fis, fis.available()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return newFixedLengthResponse("404 error,no such file"); &#125;&#125; 创建一个Service，开启HttpServer:1234567891011121314151617181920212223package sohero.com.testhlsvideo;import ...;public class MyServer extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException("Not yet implemented"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; HlsHttpServer myServer = new HlsHttpServer(8080); try &#123; // 开启HTTP服务 myServer.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.onStartCommand(intent, flags, startId); &#125;&#125; 下载m3u8文件下载m3u8文件,并进行改写，代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package sohero.com.testhlsvideo;import ...;/** * 项目名称:sohero.com.testhlsvideo * 类创建者:QHY. * 时间:2019/4/29 * 类说明:下载m3u8文件 */public class HttpFileUtils &#123; public static boolean downLoadFile(String httpUrl, String name) &#123; String HLS_PATH = Environment.getExternalStorageDirectory().getPath() + "/HlsTemp/"; try &#123; URL url = new URL(httpUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setReadTimeout(30000); conn.setConnectTimeout(3000); conn.connect(); //读到流中 InputStream is = conn.getInputStream(); byte buf[] = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((len = is.read(buf)) != -1) &#123; bos.write(buf, 0, len); &#125; //新建文件 File file = new File(HLS_PATH); if (!file.exists()) &#123; file.mkdir(); &#125; File m3u8file = new File(HLS_PATH, name); //写到流中 FileOutputStream fos = new FileOutputStream(m3u8file); fos.write(bos.toByteArray()); //关闭流 fos.close(); bos.close(); is.close(); conn.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; return writeFile(HLS_PATH + name); &#125; private static boolean writeFile(String path) &#123; File file = new File(path); FileReader reader = null; try &#123; reader = new FileReader(file); BufferedReader bReader = new BufferedReader(reader); StringBuilder sb = new StringBuilder(); String s = ""; int line = 0; while ((s = bReader.readLine()) != null) &#123; if (line &gt;= 7 &amp;&amp; line % 2 == 1) &#123; sb.append(ContentValues.NET_PATH + s + "\n"); &#125; else &#123; sb.append(s + "\n"); &#125; line += 1; &#125; String str = sb.toString(); Log.v("Tag", str); String[] strs = str.split("\""); str = strs[0] + "\"" + ContentValues.KEY_PATH + "\"" + strs[2]; FileWriter writer = new FileWriter(file); writer.write(str); writer.flush(); writer.close(); bReader.close(); reader.close(); //handler.sendEmptyMessage(0x002); Log.v("Tag", str); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; return true; &#125;&#125; 播放视频本来想随便写写activity，后来想想，还是乖乖的用mvp吧。 接口 IMainContract: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package sohero.com.testhlsvideo;import io.reactivex.Observable;/** * 项目名称:sohero.com.testhlsvideo * 类创建者:QHY. * 时间:2019/5/7 * 类说明:Main页面接口 */public interface IMainContract &#123; interface IMainPersenter &#123; /** * 获取权限 */ void getPermission(); /** * 下载文件，自己封装的RxJava */ void getHlsFile(); /** * 刷新sb,用了RxLifeCycle,防止内存泄露,感觉快用了Rx全家桶了 */ void refreshProgress(); /** * 删除文件 */ void deleteHlsFile(); &#125; interface IMainView &#123; /** * 获取权限成功 */ void getPermissionSuccess(); /** * 获取权限失败 */ void getPermissionFailed(String msg); /** * 下载文件成功 */ void getHlsFileSuccess(); /** * 下载文件失败 * * @param msg 错误信息 */ void getHlsFileFailed(String msg); /** * 刷新seekBar的progress，一秒一次 */ void refreshProgress(); /** * 播放完成，删除文件成功 */ void deleteHlsFileSuccess(); /** * 播放完成，删除文件失败 */ void deleteHlsFileFailed(String msg); &#125; interface IMainModel&#123; /** * 下载文件,耗时操作 */ Observable&lt;Boolean&gt; getHlsFile(); /** * 删除文件，耗时操作 */ Observable&lt;Boolean&gt; deleteHlsFile(); &#125;&#125; 实现类 Activity: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package sohero.com.testhlsvideo;import...;import sohero.com.testhlsvideo.video.media.UsIjkVideoView;import tv.danmaku.ijk.media.player.IMediaPlayer;public class MainActivity extends AppCompatActivity implements SeekBar.OnSeekBarChangeListener, IMainContract.IMainView, IMediaPlayer.OnPreparedListener, IMediaPlayer.OnCompletionListener &#123; UsIjkVideoView ijkVideoView;//IjkPlayer,我封装了一层，用法一样 SeekBar sb;//seekBar private IMainContract.IMainPersenter persenter; //persenter @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initView(); persenter = new MainPersenter(this, this); persenter.getPermission(); &#125; private void initView() &#123; setContentView(R.layout.activity_main); ijkVideoView = findViewById(R.id.ijk_vv); sb = findViewById(R.id.main_sb); sb.setOnSeekBarChangeListener(this); &#125; @Override public void getPermissionSuccess() &#123; startService(new Intent(MainActivity.this, MyServer.class)); //开始下载m3u8文件 persenter.getHlsFile(); &#125; @Override public void getPermissionFailed(String msg) &#123; Toast.makeText(MainActivity.this, msg, Toast.LENGTH_SHORT).show(); &#125; @Override public void getHlsFileSuccess() &#123; Toast.makeText(this, "下载完成，播放视频", Toast.LENGTH_SHORT).show(); startPlayVideo(); &#125; @Override public void getHlsFileFailed(String msg) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125; @Override public void refreshProgress() &#123; sb.setProgress(ijkVideoView.getCurrentPosition()); &#125; @Override public void deleteHlsFileSuccess() &#123; Toast.makeText(this, "播放完成，缓存文件删除成功", Toast.LENGTH_SHORT).show(); sb.setMax(0); sb.setProgress(0); ijkVideoView.release(true); &#125; @Override public void deleteHlsFileFailed(String msg) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125; /** * 开始播放视频,开始刷新进度 */ private void startPlayVideo() &#123; ijkVideoView.setVideoPath(ContentValues.LOCAL_PATH + ContentValues.FILE_NAME); ijkVideoView.setOnPreparedListener(this); ijkVideoView.setOnCompletionListener(this); &#125; @Override public void onPrepared(IMediaPlayer iMediaPlayer) &#123; ijkVideoView.start(); sb.setMax((int) iMediaPlayer.getDuration()); persenter.refreshProgress(); &#125; @Override public void onCompletion(IMediaPlayer iMediaPlayer) &#123; persenter.deleteHlsFile(); &#125; /** * seekBar相关 * * @param seekBar * @param progress * @param fromUser */ @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; ijkVideoView.seekTo(seekBar.getProgress()); &#125;&#125; Persenter: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package sohero.com.testhlsvideo;import java.util.concurrent.TimeUnit;import ...;/** * 项目名称:sohero.com.testhlsvideo * 类创建者:QHY. * 时间:2019/5/7 * 类说明:Persenter */public class MainPersenter implements IMainContract.IMainPersenter &#123; private IMainContract.IMainView view; private IMainContract.IMainModel model; private MainActivity activity; public MainPersenter(IMainContract.IMainView view, MainActivity context) &#123; this.view = view; this.activity = context; model = new MainModel(activity); &#125; @Override public void getPermission() &#123; USUtils.getInstance().usePermission() .setContext(activity) .setPermission(UsConst.Permission.WRITE_EXTERNAL_STORAGE) .getPermission(new UsPermission.PermissionCallBack() &#123; @Override public void success() &#123; view.getPermissionSuccess(); &#125; @Override public void failed() &#123; view.getPermissionFailed("please get permission for app"); &#125; &#125;); &#125; @Override public void getHlsFile() &#123; model.getHlsFile() .subscribe(new UsRxJava&lt;Boolean&gt;() &#123; @Override public void _onNext(Boolean s) &#123; view.getHlsFileSuccess(); &#125; @Override public void _onError(String msg) &#123; view.getHlsFileFailed(msg); &#125; @Override public void _onFinish(Disposable d) &#123; &#125; &#125;); &#125; @Override public void refreshProgress() &#123; Observable.interval(1, TimeUnit.SECONDS).compose(UsRxJava.&lt;Long&gt;thread_main()).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; view.refreshProgress(); &#125; &#125;); &#125; @Override public void deleteHlsFile() &#123; model.deleteHlsFile() .subscribe(new UsRxJava&lt;Boolean&gt;() &#123; @Override public void _onNext(Boolean aBoolean) &#123; view.deleteHlsFileSuccess(); &#125; @Override public void _onError(String msg) &#123; view.deleteHlsFileFailed(msg); &#125; @Override public void _onFinish(Disposable d) &#123; &#125; &#125;); &#125;&#125; model: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package sohero.com.testhlsvideo;import android.os.Environment;import java.io.File;import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import qhy.com.unlimitedswordutils.USUtils;import qhy.com.unlimitedswordutils.UsObservable;import qhy.com.unlimitedswordutils.UsRxJava;/** * 项目名称:sohero.com.testhlsvideo * 类创建者:QHY. * 时间:2019/5/7 * 类说明:model */public class MainModel implements IMainContract.IMainModel&#123; private MainActivity activity; public MainModel(MainActivity activity) &#123; this.activity = activity; &#125; @Override public Observable&lt;Boolean&gt; getHlsFile() &#123; return USUtils.getInstance().useRx().create(new UsObservable.UsSubcribe&lt;Boolean&gt;() &#123; @Override public void doSomeThings(ObservableEmitter&lt;Boolean&gt; e) &#123; boolean result = HttpFileUtils.downLoadFile(activity, ContentValues.NET_PATH, ContentValues.FILE_NAME); if (result) &#123; e.onNext(true); &#125; else &#123; e.onError(new Throwable("download failed")); &#125; &#125; &#125;).compose(UsRxJava.&lt;Boolean&gt;io_main()); &#125; @Override public Observable&lt;Boolean&gt; deleteHlsFile() &#123; return USUtils.getInstance().useRx().create(new UsObservable.UsSubcribe&lt;Boolean&gt;() &#123; @Override public void doSomeThings(ObservableEmitter&lt;Boolean&gt; e) &#123; File file = new File(Environment.getExternalStorageDirectory() + "/HlsTemp/" + ContentValues.FILE_NAME); if (file.exists() &amp;&amp; file.isFile()) &#123; file.delete(); e.onNext(true); &#125; else &#123; e.onError(new Exception("no such file")); &#125; &#125; &#125;).compose(UsRxJava.&lt;Boolean&gt;thread_main()); &#125;&#125; 地址 123456789101112131415161718package sohero.com.testhlsvideo;/** * 项目名称:sohero.com.testhlsvideo * 类创建者:QHY. * 时间:2019/5/7 * 类说明:地址 */public class ContentValues &#123; //本地视频地址 public static final String LOCAL_PATH = "http://127.0.0.1:8080/"; //网络视频地址 public static final String NET_PATH = "http://www.qingheyang.studio:8000/program/testHlsVideo/"; //key地址 public static final String KEY_PATH = "http://www.qingheyang.studio:8000/program/testHlsVideo/key/enc.qhy"; //保存的文件名称 public static final String FILE_NAME = "butter_fly_list.m3u8";&#125; 总结视图我就不上了，这个项目回头我给上传一下github，节省篇幅，我把import的包全给删掉了。总体思路就是上述那样，在服务器上的m3u8文件是个假文件，就算是抓包也是抓到的假文件，到移动端，改写m3u8，填入正确信息，在URI上面填入正确的key路径信息，做到无法盗取全链。因为我不会写后台，所以对接口也比较蒙，其实完全可以先获取下token，然后改写URI，服务端要验证token后才返回文件，这样会更好一些。 写在最后应该是以后不会更新这两篇文章了，毕竟要换工作了，不知道会不会还是继续深入研究，如果有什么不懂的话，可以下面问我，也可以戳我邮箱 775495797@qq.com ，匆匆忙忙的写的这篇文章，很多地方还没校对，先这样。 —————–更新—————–花了点时间校对，改了下demo，顺带把项目上传到github中，在给几个传送门： demo资源（有教程，可也以看我以前的那篇文章）：点这里项目github（欢迎给star）：点这里项目zip下载（as:3.4,gradle:4.8.1,gradle-tools:3.2.1）：点这里 以上]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
        <tag>ijkPlayer</tag>
        <tag>HLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次HLS视频加解密方案的过程（1）]]></title>
    <url>%2Farchives%2Fa137cd06.html</url>
    <content type="text"><![CDATA[前言&amp;背景最近脑壳很疼，事情是这样的。很久之前，公司的一个app产品要播放视频教学文件，我跟一个哥们一合计，本来想的是弄一个VideoView，封装一个MediaController，简单实用。后来等原型出来后，我们技术准备也完成了，领导突然说，视频是flv的，当时就傻眼了，换播放器，编译ijk，编译ffmpeg，各种折腾，算是折腾好了，项目也上线了。再后来，最近，领导说要视频加密，又傻眼了，没弄过啊，我一移动端不会啊，好在当初折腾过NDK，也折腾过ffmpeg，就开始了视频加密。 方案现在公司移动端就剩我一个人了，ios也跑了。后台的兄弟天天忙别的，PC端的视频加密，是加密的flv文件，买的别的公司的技术服务，我大致看了下，应该是自己写了个编码器，加密视频进行编码，然后播放的时候用的ffplay，自己套一个自己写的解码器，我感觉我技术还是达不到写编码器解码器这个水平的，就转战研究前人走过的路。我折腾出了两种方案，大致是： 对mp4静态文件加密。 对mp4视频转为hls视频流。 mp4静态文件加密这个方案很简单，原理就是先把mp4文件通过流读取，然后再保存，过程插入加密的字符就ok了。 优点：操作起来简单，不用耗工时。 缺点：一是加密的太简单了，二来没办法做到即时播放，一定要下载到手机上才可以播放，很鸡肋。 加密代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.QingHeYang;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;public class ChangeMp4 &#123; private static String sourcePath = "E:/source.mp4"; private static String targetPath = "E:/target.mp4"; public static void main(String[] args) &#123; encodeMp4(); &#125; public static void encodeMp4()&#123; File sourceFile = new File(sourcePath); File targetFile = new File(targetPath); FileInputStream input = null; BufferedInputStream inBuff = null; FileOutputStream output = null; BufferedOutputStream outBuff = null; try &#123; input = new FileInputStream(sourceFile); inBuff = new BufferedInputStream(input); output = new FileOutputStream(targetFile); outBuff = new BufferedOutputStream(output); outBuff.write(encrypt("value", "key")); byte[] b = new byte[1024 * 5]; int len; while ((len = inBuff.read(b)) != -1) &#123; outBuff.write(b, 0, len); &#125; outBuff.flush(); inBuff.close(); outBuff.close(); output.close(); input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; outBuff.flush(); inBuff.close(); outBuff.close(); input.close(); output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static byte[] encrypt(String content, String password) &#123; try &#123; KeyGenerator kgen = KeyGenerator.getInstance("AES"); kgen.init(128, new SecureRandom(password.getBytes())); SecretKey secretKey = kgen.generateKey(); byte[] enCodeFormat = secretKey.getEncoded(); SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES"); Cipher cipher = Cipher.getInstance("AES"); byte[] byteContent = content.getBytes("utf-8"); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] result = cipher.doFinal(byteContent); return result; &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 加密效果还行吧，只能说能糊弄一下不懂的人，效果如图。未加密的二进制文件：加密的二进制文件对比：在头部加了AES-128加密的字符，其实不一定在头部加，可以在任意地方加，就强度来说，还算可以。但是有一个问题，因为我用的ijkPlayer，这个播放器是用ffmpeg编译解码器，然后用ffplay播放画面，输出到android的surfaceView上面的，所以，在Java的api层面，是找不到对这个文件进行流的操作的。所以，这就涉及到另一个问题，我该怎么播放了，众所周知的是，无论是VideoView还是市面上的ijk也好，vitamio，更原始一点的surfaceView，都有setVideoPath这个api，都没有ImageView的类似setStream这种对文件流的操作。所以，这就意味着阻断了在Java的api的对视频文件的流操作（我是真的追源码了，最后追到jni层，没法继续下去了），也就意味着没法编解码边播放了，只能下载下来，然后用File的方法，进行decode，这样不是很友好的，因为，一但下载下来，再decode，这样一是浪费了Android手机宝贵的内存控件，二来，解密完后，视频源文件不还是成了未加密的了吗！这不是白玩了吗。其实也不是不能边解密边播，但是目前来，我的水准还是达不到的，但是大致思路就是，用ijkPlayer编译的过程自定义视频解码器，把自己的视频解码器替换调mp4的解码器，这样，能做到边解密边播（很遗憾，水平不够）。 HLS视频流放弃掉mp4解密的大坑后，我转战HLS流的形式。这个形式，好处很多，市面上最流行的，文件加密性好，有链保护，获取不到源文件，获取到了，外行也不会操作，balabala….说一下优缺点： 优点：技术成熟，会编译，明白原理基本就ok了，加密性好。 缺点：不好说，这个缺点多半是我自身缺点，水平有限。 做HLS视频流要准备一些东西，我列一下： linux：要用到这个编译ffmpeg，看一下ffmpeg官网，windows也可以，不过会很麻烦。 ffmpeg源码：下载下来要编译的。 ijkPlayer源码：播放加密视频用。点击这里去ijkPlayer。 mp4源文件：原材料要准备好。 tomcat/nginx/apache：服务器，必需品，hls中key文件，以及视频文件都需要用到。 HLS文件构成先说一下hsl加密视频流的组成内容： .m3u8文件：视频索引文件。 .ts文件：视频片段。 .key文件：加密秘钥（AES-128，同mp4加密用的一样的手段）。 .keyInfo：加密时用的文件，写入.m3u8里面的过程文件。 HLS是基于MP4生成的，将mp4文件切片，在对每一个切片文件加密，然后将这些切片文件的序列进行集合，生成索引文件.m3u8，一个完整的HLS视频流如下图所示：未加密： 加密：未加密的.ts文件可以用播放器直接打开，且在切片的时候不能修改后缀名。加密的.ts文件不可以直接用播放器打开，可以在生成切片文件时候修改后缀名。.m3u8文件的内容如下，这个我就只上加密的了，毕竟这个是重点：1234567891011121314151617181920212223#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:35#EXT-X-MEDIA-SEQUENCE:0#EXT-X-PLAYLIST-TYPE:VOD#EXT-X-KEY:METHOD=AES-128,URI=&quot;http://ubuntu.shouwangzhe.space/video/source2lock/source2.key&quot;,IV=0x67e6af3d7b4117a01831d6b3a8741df1#EXTINF:34.661933,source2_0_ts#EXTINF:26.736822,source2_1_ts#EXTINF:29.197778,source2_2_ts#EXTINF:31.658733,source2_3_ts#EXTINF:33.827711,source2_4_ts#EXTINF:32.534667,source2_5_ts#EXTINF:22.106889,source2_6_ts#EXTINF:5.797844,source2_7_ts#EXT-X-ENDLIST 编译ffmpeg因为这块遇到了些问题，但是最终解决了，就简单说一下步骤，ffmpeg编译网络上有很多教程的。1.先安装gcc+yasm，这个比较重要，必备。123$ sudo apt update$ sudo apt-get install gcc$ sudo apt-get install yasm 2.下载ffmpeg，地址点击这里。123$ mkdir ffmpeg$ cd ffmpeg$ git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg 3.编译ffmpeg。12$ cd ffmpeg$ ./configure --enable-shared --disable-static --disable-doc 然后会执行很久，完成之后make。12$ make$ make clean 之后就完成了，大致内容如下然后就是对视频的操作了。 加密视频1.准备好一个source.mp4文件，用于加密，放置在一个文件夹下面，准备好两个文件夹，一个放置加密的，一个放置未加密的，大致如下：2.生成要加密的key，前提要有openssl。123$ cd source2lock$ openssl rand 16 &gt; source2.key$ cat source2.key 保存下生成的这个偏移量。3.生成偏移量 IV。1$ openssl rand -hex 16 &gt;source2.iv.txt 4.生成hls_key_info_file。12$ touch source2.keyinfo$ vi source2.keyinfo 5.用vi写入如下内容。123456#你要存秘钥的地址，最好是个网络地址http://ubuntu.shouwangzhe.space:1994/video/source2lock/source2.key#刚才你生成的key文件source2.key#刚才你保存的偏移量67e6af3d7b4117a01831d6b3a8741df1 6.视频切片+加密，记得将这些命令写到一行上去，我这么些是因为容易看一些。123456789ffmpeg -i ../source2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb -hls_time 30 -hls_key_info_file source2.keyinfo -hls_playlist_type vod -hls_segment_filename "source2_%d_ts" source2_list.m3u8 出现以下结果就成功了,注意小红框的内容,crypto，后续用的到7.视频未加密，也顺带给上一个未加密的命令吧。12345678ffmpeg -i ../source2.mp4 -codec copy -vbsf h264_mp4toannexb -map 0 -f segment -segment_list source2_list.m3u8 -segment_time 30 source2_%d.ts 转为在线视频流有加密视频文件了，就需要一个http服务器来支撑播放。大致有三种方式，一种比一种简单： nginx：vi /etc/nginx/sites-avaliable/default 就ok，配置端口，静态文件夹 tomcat：最常用的一种，将视频文件夹扔到webapps下面即可，然后./startup就ok的。 apache：也是经常用到的http服务器，但是我没用过，就不详谈了。 但是无论上述哪一种一定记得，key所在的位置就是刚才加密视频的时候编写hls_key_info_file里面key的位置。 播放加密视频加密完视频后，可以算是成功一半了，剩下的就是解密视频了。我记得ijkPlayer支持播放加密的m3u8的问题，于是乎，我直接把视频地址扔进ijkPlayer中，想着应该大功告成了，但是天道好轮回，苍天绕过谁。提示是我自己编写的，ijkPlayer是我曾经编译的。经过研究发现个问题，我这个ijk，好像不支持加密的hls啊！上一下当时的loagcat：可以看到第一，我的key没有问题，第二视频列表已经索引出来了。但是唯独加载不出来视频片段1。经过我漫长的寻找解决答案，终于碰到了个明白人，解决了我解密hls播放不出来的问题。地址：https://segmentfault.com/q/1010000006751909因为在我ijk编译的过程中，选择的最简略的解码器，外加协议上面没有添加多种协议。所以，我重新编译了ijkPlayer。因为过程太过复杂，具体请看github上面的教程。地址：https://github.com/bilibili/ijkplayer这里我给一下我服务器上面的已经编译好的包，免去繁琐的编译过程啦。ijk编译好的包下载地址：点击下载具体用法请自行百度。上一下贼简单的activity代码(不然证明不了我是Android程序员啊)：1234567891011121314151617181920212223242526272829package sohero.com.testhlsvideo;import android.content.Context;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import sohero.com.testhlsvideo.video.media.IjkVideoView;import tv.danmaku.ijk.media.player.IMediaPlayer;public class MainActivity extends AppCompatActivity &#123; IjkVideoView vv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); vv = (IjkVideoView) findViewById(R.id.ijk_vv); vv.setVideoPath("http://192.168.31.222:8090/coursePackage/hls/lock/source2_list.m3u8"); vv.setOnPreparedListener(new IMediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(IMediaPlayer iMediaPlayer) &#123; vv.start(); &#125; &#125;); &#125;&#125; 效果图： 将来的方向这套还是有些问题的，例如对key文件保存的不周到，加密的不够好，懂行的人也是能获取全链的，等等等等。将来的方向我还是想着以操作m3u8文件为主，对视频链路进行保护，着重保护key文件，二次加密等等，现在先这样，等想出来我再补充。 最后全部搞完历时三天，从不明白HLS，到最后实现出来，总体来说还是挺有成就感的，这大概就是做一个开发工程师的快乐所在吧，如果这篇文章有幸被你看到了，你有什么不懂的地方欢迎留言，我写的毕竟还是太粗糙了，我会尽我所能去帮你，就这样。以上]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
        <tag>ijkPlayer</tag>
        <tag>HLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客那点事，一些技术上的延伸]]></title>
    <url>%2Farchives%2Fbd8a7f1a.html</url>
    <content type="text"><![CDATA[前言2018年年初的时候我弄得hexo博客，到现在满打满算1年多，在上半年用的比较多，下半年我就销声匿迹了，很少写，这与懒不懒惰无关，是因为我自己的服务器遭受到了重创，数据全部被清空了，也就是说，我个人的服务全都挂了。大概就是自己弄得文件系统、博客系统、游戏服务、还有一大堆费心写的费心编译的项目，全GG，至于为什么没有备份，因为那是我自己用旧电脑改装的服务器啊喂！！！我眼前还浮现着之前美滋滋弄得漂亮的博客的样子，就是下面这个样子，我还完善了很多漂亮的主题。后来因为之前把博客部署到github.io了，所以文字性的东西勉强还算能够找到，图片是废了，更别说我的tomcat服务了。最后总结出来一个，ubuntu经不起突然断电的折腾，因为有一天突然停电了，我的服务器就挂了，痛定思痛，我今年决定把博客再给前捡起来，然后在做一系列的风控措施吧，虽然我也不是运维，hahahaha。 框架首先说一下，这篇博文主要是说一下hexo博客的延伸，需要有一定的linux基础以及会部署hexo项目的经验，最好有一些网络经验。我研究了一下我要做到什么样子，才算是能让我觉得满意的博客。 服务器：首先是在自己的服务器上面进行操作。 Hexo主体：这块就介绍一下要安的包。 主题：这块就比较鸡肋了，一般会部署的都会切换主题。 资源：博客的资源操作，要怎么用。 自动化：必须能够做到能够自动generate，自动deploy，以及backup，否则一切免谈。 网络：项目部署后，要有自己的域名，而且要ssl证书的那种。（要求太过分了，hahahaha） 上面这些是我能想到的，还有些可能没有理清的，后续再说吧。 服务器如果你只是想部署一个hexo项目，并且只会选择github.io作为主站点，那你可以点击右上角，然后去找一找比别的教程了。服务器是整个项目必备的，而且一般都是linux，可以有以下几种选择。 云服务器：优点是可以icp，固定ip（这就很舒服了），缺点也很明显，贵啊。 自己搭建服务器：优点，自己可控，随意造，最重要的是，随随便便的i7+16G内存，无论做什么，编译速度不是完爆1核1G1Mb了，缺点就是，这个对你网络的运营商要求比较高。还有一点是，如果你家里网可以翻墙，自己的服务器还是有些优势的。 很明显我选择的第二种，因为考虑到性能问题（qiong），我当初做的服务器就是用旧电脑搭建的，就是下面这个。还有我的运维环境，毕竟是在家里，不要在意那么多。服务器系统是ubuntu server，经历过断电后，我就选择了server系统，而不用普通的ubuntu了，没有用centOS，因为对Debian这系列有好感，小版本是18.0.4。安装教程可以自行百度，可以参照这个。 Hexo主体考虑到网络上太多的Hexo教程，以及能研究到延伸这里的，基本都是会的，不过我还是贴心的给挂上几个连接，以及一定要安装的一些包。 Hexo官网文档（免去你一会去百度了） Hexo Themes 地址，主题地址（有时候得挂一下代理） Hexo 插件地址 其实安装的话，看官网教程就可以了，如果你会一些linux知识，当然你要会前端那就更NB了。先安装npm、nodeJs、以及hexo。12$ sudo apt-get install nodejs $ npm install -g hexo-cli 好像是上面这样，网上教程很多的，因为太久远了，有些忘了，不过这些也不是重点。插件大概有一些。hexo-admin，必装，因为这个编辑真的很舒服，教程点这里。1$ npm install --save hexo-admin 效果如下： hexo-deployer-git,必装，hexo部署到github.io的插件，教程点这里。1$ npm install hexo-deployer-git --save 暂时想这么多，后续再补吧。 主题我感觉这块大家都明白，如果你懂一些前端知识，还是可以在人家已有的主体上面给修改一些东西的。例如之前这个主题的代码字体不好看，可以去对应的主题下面，找到css文件，修改一下颜色，网页中按f12，查看具体的位置，其实我是真不太懂这块的，连蒙带侃的找到了对应的位置，修改了颜色。我这个主题是Diaspora，我还是觉得挺好看的。 资源这个资源怎么说呢，主要就是图片，音频，因为曾经博客丢失过，所以我就决定，弃用hexo自带的assert资源文件夹了，这个文件夹是文章对应的图片文件夹。这个主要是要是整个项目丢了，那简直是灾难，所以我决定图片内文章全用图床形式，网络图片。图床有几种选择： 七牛 存储桶 github 自建http服务器。 很明显，我也选择的最后一种，大概是程序员的执拗，我一向喜欢用自己的服务器。其实我也纠结了很久哪个更好点，毕竟除了自建服务器，其余的都是https协议（后面解释原因），也不花钱，但是我还是太懒了，hahahaha。最后我选择了自己搭建nginx服务器，因为以前做ffmpge用到过，比tomcat更符合我的风格。话不多说，先安装：1$ sudo apt-get install nginx 然后配置，此处需要权限：1$ sudo vi /etc/nginx/sites-available/default 然后配置静态路径，具体内容需要修改为自己想开方的路径以及端口号：123456789101112131415server &#123; listen 80 default_server; listen [::]:80 ipv6only=on default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; charset utf-8; server_name _; location / &#123; root /home/qingheyang/share/; autoindex on; &#125; &#125; 然后开启 or 重启：1$ sudo nginx -S reload 如果你最后在浏览器输入你自己的ip或者域名，加nginx监听的端口号，能看到下面结果，说明成功了。然后就可以在文章中引用了，需要注意的是，这些图片不能丢失，否则文章中图就挂了。当然，这仅仅是我的选择，其实github，或者七牛都是不错的选择。毕竟稳定，不收费。（2019-04-18补充）其实markdown也可以上传视频的，通过下列代码插入到.md文档中就可以了：12&lt;video src=' ' type='video/mp4' controls='controls' width='100%' height='100%'&gt;&lt;/video&gt; 自动化无论何时，其实都可以考虑自动化，除去不长期开着项目的，只往github上更新的童鞋。 一键上传博客我在去年的一篇文章里写了怎么用expect做到一键更新项目到github.io上去，再贴一下脚本吧。1234567891011121314151617#脚本里的用户名密码都需要修改#!/usr/bin/expect -fset gitUser QingHeYangset gitPsw *******set userPsw *******spawn ssh qingheyang@localhostexpect "password:" &#123;send "$userPsw\r"&#125;expect "qingheyang@*" &#123;send "cd /home/qingheyang/Hexo/QHY_Blog2\r"&#125;expect "qingheyang@*" &#123;send "hexo g\r"&#125;expect "qingheyang@*" &#123;send "hexo d\r"&#125;expect "*Username*" &#123;send "$gitUser\r"&#125;expect "*Password*" &#123;send "$gitPsw\r"&#125;expect eofexit 0 编辑完后，记得：1$ chmod 脚本.sh u+x 然后执行一下，你会发现，系统自动登陆，然后给你自动输入密码然后把项目deploy到github.io上去了。这个有前提的，一定要配置hexo-deployer-git。 计划任务计划任务主要是要做备份用，将整个项目以及网络资源还有服务器的部分内容，按时给备份到某一个地方去。这回我给我的博客加上了备份功能， 因为静态页可以随时随地查看，但是静态页是没法反向转成项目工程的，一但项目工程丢失了，你的博客也就止步于此了。所以备份必不可少，怎么备份呢，我的思路大概是： 1 .将自己的Hexo博客源文件夹以及图床文件夹，拷贝到一个目录中（也可以带入服务器比较关键的文件）。2 .将这些文件压缩。3 .将压缩文件上传。 技术点是： 1 .用ubuntu自带的计划任务，每周一、周四执行备份命令与脚本。2 .用阿里云sdk上传至阿里云OSS中。 计划任务什么是计划任务，计划任务是ubuntu定时执行的命令，具体教程可以参照这个,我定的是每周一周四，18:20开始备份，18:40截止备份。计划任务具体操作如下：1&amp; crontab -e 然后让你选择用哪个编辑器，有nano，有vi，我手滑了，选的nano，界面如下：里面的白字是我手动输入的，注意，计划任务的命令最好用绝对路径。12345678910# 第5步，18:40执行上传文件到OSS的jar包40 18 * * 1,4 /home/qingheyang/Java/jdk1.8.0_181/bin/java -jar /home/qingheyang/server_back_up/utils/utils.jar# 第4步，18点30压缩备份文件夹30 18 * * 1,4 zip -r /home/qingheyang/server_back_up/zipfile/backup.zip /home/qingheyang/server_back_up/sourcefile# 第3步，18:27 复制我的世界文件夹进入备份文件夹27 18 * * 1,4 /bin/cp -r /home/qingheyang/minecraft/newworld /home/qingheyang/server_back_up/sourcefile/minecraft# 第2步，18:25 复制图床文件进入备份文件夹25 18 * * 1,4 /bin/cp -r /home/qingheyang/share/blog_image /home/qingheyang/server_back_up/sourcefile/blog# 第1步，18:20 复制博客工程进入备份文件夹20 18 * * 1,4 /bin/cp -r /home/qingheyang/Hexo/QHY_Blog2 /home/qingheyang/server_back_up/sourcefile/blog 然后输入 Ctrl+o ，写入文件即可，按Ctrl + x，退出nano编辑器，然后重启计划任务：1$ service cron restart 可以输入命令查看当前用户的计划任务：1$ crontab -l 云备份（2019/04/16补）定期打出来的压缩包是可以上传到某一个地方去的，有很多种选择，因为我域名是在阿里云买的，所以我就选择了阿里云的OSS存储器，价格低，很低很低，也方便管理，他有sdk给提供。我做了个Java工程，打了个jar包，就当做是脚本来运行了。 阿里云OSS地址：https://www.aliyun.com/product/oss?spm=5176.8142029.selected.3.fbcf6d3eyuSIHf 贴一下java代码，最简单的文件上传：12345678910111213141516171819202122232425262728package com.qhy.backup;import java.io.File;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import com.aliyun.oss.OSSClient;public class UploadBackupFile &#123; public static void main(String[] args) &#123; String endpoint = "http://oss-cn-beijing.aliyuncs.com"; String accessKeyId = "&lt;你的accessKey&gt;"; String accessKeySecret = "&lt;你的accessKeySecret&gt;"; OSSClient ossClient = new OSSClient(endpoint, accessKeyId, accessKeySecret); //地址一定要选绝对路径地址，不然会出错误 String backupPath = "/home/qingheyang/server_back_up/zipfile/backup.zip"; Calendar c = Calendar.getInstance(); c.setTime(new Date()); //以时间命名的备份文件 String fileName = (new SimpleDateFormat("yyyy-MM-dd-HH:mm:ss")) .format(c.getTime()) + "_backupfile.zip"; ossClient.putObject("&lt;你新建的bucket名称&gt;", fileName, new File(backupPath)); ossClient.shutdown(); &#125;&#125; 通过引入阿里云的sdk,然后打成jar包，扔进服务器，最后通过计划任务java -jar定时运行就可以了。效果如下：这是已经上传好的备份文件，阿里云也提供下载功能，具体代码编写就不贴了，有教程的，而且，服务器如果不崩溃的话，是用不到的。 这样通过上述两步，定时将博客重要的文件备份上传就完成了，总结一下问题： 还不完备，其实可以都写到java里面，然后一步执行即可，现在这样写存在异步的问题，有可能这边没压缩完，下一个计划任务就已经开始上传了，只不过我懒得写代码了，给预留的时间也足够，hahaha. OSS既然应用了，其实这个博客可以实现的很简单，我也没必要将他上传到github.io中去了，当一个静态存储桶也是够的。 最大的问题就是，写的不够清晰明了，我省略了很多步骤，其实这篇文章可以细分很多很多方向，但我给集合到一起了，效果不是很好。 网络这个可以重点说一下，因为这块涉及到域名、端口号、ssl证书等一系列的问题。 服务器网络先说一下前提：你没有自己的云服务器，可能因为qiong，也可能因为你跟我有一样，有废弃的性能比较好的电脑，这是大前提，如果你有云服务器，不管是阿里云ECS，还是亚马逊AWS，你可以省略这块了，整篇文章对你来说都没有意义。 自建服务器有个很大的缺点，就是非固定ip，甚至有可能是非公网ip。这就涉及到很严重的问题，如果非公网ip，就意味着你的博客外网访问不到，因为网络是一层套一层的，你的服务器链接你的路由器，你的路由器连接着外网，这是必备条件。如果你的运营商可以提供公网ip，但是你查询到的ip不是公网ip，那就需要你做一些措施了。具体怎么查询呢，首先你需要连接上自己的wifi，然后百度一下，ip，然后看一下结果，然后登录自己的路由器，看一下ip，如果一致，恭喜你，运营商还算良心，如果不一致，可以致电运营商，讨要公网ip，没错，你有这个权利的。有公网ip后，你需要在路由器进行端口映射，具体的方法，要看什么路由器了，需要映射的端口号有这些： 22端口:远程ssh以及ftp必备。 80端口:nginx监听的默认是80.其实可以修改的，对外接口一定不能是80，政策不给你开80端口的。 4000端口:hexo服务器默认端口，作用是你想随时随地编写博客，就得一直开着。 映射出去后，就可以远程对这些进行操作了。最后的效果是，将自己的域名绑定ip，然后编写完博客后deploy到github.io上去，然后阿里云域名直接指向githu.io，做到个人域名访问发布的博客，最后一部是添加ssl证书。达到现在这个博客的样子。因为涉及到太多东西了，所以我有点不知道怎么写了，以后慢慢补吧，先告一段落。 写在最后其实还有很多要写，seo站点优化，提交给百度及谷歌，添加访问量等等等等，但是有点写不下去了，先写写别的，如果我的这篇文章有幸被你看到了，有什么不明白的地方，可以通过留言告诉我，尽我所能去帮你。啊对了，说一下我现在的这个效果吧： 我可以在任何一个地方编写我的博客，地址是http://www.qingheyang.studio:1314。 每周自动准时备份，备份完成后会给我发送短信。 就这样，以上]]></content>
      <categories>
        <category>综合技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>hexo</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于互联网技术]]></title>
    <url>%2Farchives%2Fdc492ad2.html</url>
    <content type="text"><![CDATA[互联网技术 前端：android\ios，react，jsp，vue。 后端：java js .net C#。 dba：mysql oracle mangodb。 运维：windows server 、 linux 、 tomcat 、Apache 、nginx、docker。 new tech. : hadoop、tensorflow、caffe。 混合：react native 、pwa、flutter(update in 2019/04/24)。 我就是想列一下存在的这些技术，可能你比我明白，要是写错的地方，让您见笑了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于机器学习的一些想法(持续更新中)]]></title>
    <url>%2Farchives%2F7b334ee0.html</url>
    <content type="text"><![CDATA[我现在的情况是处在半迷茫阶段了。我已经24了，今年结的婚，算是结婚尚早的。不提个人生活，我在工作上面也存在很大的迷茫，不知道该往哪个方向走。前段日子定下了走人工智能，这算是我自主学习的半年来定下的结果吧。 现在在学习人工智能，罗列一下现在掌握的信息： 人工智能的本质是模型。 模型有很多，需要自己来通过高等数学来编写。 框架是tensorflow，或者caffe。 tensorflow需要用到的是python。 目前刚刚学习了决策树。 损失函数、激活函数。 卷积CNN原理，降维、反向传播、共享权值、纹理。 其实想学人工智能这个方面也跟我小时候的执念有关，哪个孩子心底不存在一个人工智能的梦啊。既然父母把我放出来了，我就不想着去做生意了，我要选择的不是一个三流的执行工程师，而是一个真正的工程师。]]></content>
      <categories>
        <category>New Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Mac打造一个顺手的链接Linux工具]]></title>
    <url>%2Farchives%2Fe8e9078e.html</url>
    <content type="text"><![CDATA[背景Mac的话也买了有一段时间，2017款的，作为一个Android程序员，虽然买苹果的本子会让人觉得有种投敌的感觉，但是不得不说，真的实在是太好用了。作为一个Android程序员，怎么能离开Linux呢？无论是NDK还是.so库的编译，再到ffmpeg，都需要用到Linux。因为朋友的关系，我对Linux还算比较熟悉，能够使用基本的命令，cd ，ls -al，htop这些命令就不说了，makefile也写过部分，脚本也写过一部分，不过应用场景较少罢了。那么问题就来了，与Linux同源的Mac OS会不会对Linux开发有着更好的支持。 环境 Linux服务器：Ubuntu 16.04 服务器：用的机器是一台老联想，8G内存，i5cpu，256 SSD 域名：www.shouwangzhe.space (大佬不要攻击我,现在已经更换了) MacBookPro: Mac OS 工具:Shuttle解释一下为什么不用阿里云：之所以没有选择阿里云服务器，主要因为是觉得没必要，1Mb的速度，1G内存，1核cpu，一个月100多，何必呢？ 效果效果基本是很傻瓜的一种方式，顶部的图标点击后，选择哪个操作，选择登陆远程服务器:然后就会蹦出控制台的窗口:然后我们就能愉快的ls了。或许你觉得这个有什么意思，用命令不还是能解决吗，打开控制台，输入： ssh -p 22 xxx@www.域名.com #输入密码 不一样能进去吗？如果遇到复杂问题，例如你想把自己的hexo博客推送到githup.io上去呢。 #首先要 xxx@Lenovo-IdeaPad-Y480:~$ cd /hexo #然后1 xxx@Lenovo-IdeaPad-Y480:~/hexo$ hexo g #然后2 xxx@Lenovo-IdeaPad-Y480:~/hexo$ hexo d #然后3 输入你git的本地密码 Enter passphrase for key '/home/star/.ssh/id_rsa': xxxxxx #推送成功 所以我觉得自动化还是挺重要的,点击一下，一步到位。 实现实现的方式也是，会的不难，难的不会，基本是由两部分组成，Linux的expact命令，以及Shuttle。 ShuttleShuttle 是一款图形界面化的cmd命令工具。下载完后点击图标，就可以在顶部的导航栏找到他了，至于怎么用，点击这个按钮:会打开一个文档，json格式的，也就是软件的配置文件(缩进好像有点问题)： { "_comments": [], "editor": "default", "launch_at_login": false, "terminal": "Terminal.app", "iTerm_version": "nightly", "default_theme": "Ocean", "open_in": "new", "show_ssh_config_hosts": false, "ssh_config_ignore_hosts": [], "ssh_config_ignore_keywords": [], "hosts": [ { "linux Servers": [ { "QHY’s linux Servers": [ { "cmd": ".//linux自动脚本/login.sh", "inTerminal": "tab", "name": "login", "theme": "Ocean", "title": "ShouWangZhe" } ] }, { "博客运维脚本": [ { "cmd": ".//linux自动脚本/starHexoBlog.sh", "inTerminal": "tab", "name": "长时启动博客服务器", "theme": "Ocean", "title": "ShouWangZhe" }, { "cmd": ".//linux自动脚本/starHexoBlog-RealTime.sh", "inTerminal": "tab", "name": "实时启动博客服务器", "theme": "Ocean", "title": "ShouWangZhe" }, { "cmd": ".//linux自动脚本/endHexoBlog.sh", "inTerminal": "tab", "name": "关闭博客服务器", "theme": "Ocean", "title": "ShouWangZhe" } ] } ] }, { "Android adb Servers": [ { "QHY’s Home adb Servers": [ { "cmd": "adb connect 192.168.10.211:5555\r exit\r", "inTerminal": "tab", "name": "connect home onplus 2 test", "theme": "Homebrew", "title": "ShouWangZhe 1+" }, { "cmd": "adb disconnect 192.168.10.211:5555\r exit\r", "inTerminal": "tab", "name": "disconnect home onplus 2", "theme": "Homebrew", "title": "ShouWangZhe 1+" } ] } ] } ] } 上面的是我的配置，解析一下这个json：{也就是对应我的效果那节的那个图，配置文件中的host节点是我们要用到的节点，有点编程基础的也知道这个节点是一个JsonArray。下面可以加很多节点，每一个节点都是一级菜单，大体目录就这么多，每个节点的配置如下： { "cmd": ".//linux自动脚本/login.sh", "inTerminal": "tab", "name": "login", "theme": "Ocean", "title": "ShouWangZhe" } cmd：你要在打开的控制台里面输入什么命令。 name：标题。 theme：Mac控制台主题，我选的是Ocean。 title：Mac控制台标题。 我是一个android工程师，所以偶尔也需要wifi ADB操作，同样可以写在配置里面： { "cmd": "adb connect 192.168.10.211:5555\r exit\r", "inTerminal": "tab", "name": "connect home onplus 2 test", "theme": "Homebrew", "title": "ShouWangZhe 1+" } 效果就是这样的：以上大体就是Shuttle的应用，它就是读取cmd节点的命令，然后执行。 expact很明显，上面的命令我输入了执行脚本的命令。 .//linux自动脚本/login.sh 我在Mac目录下面建立了“linux自动脚本”这个文件夹，专门用来存放我的脚本。例如想要登陆远程服务器的脚本(login.sh)内容如下： #!/usr/bin/expect -f set psw 123456 spawn ssh -p 22 root@www.shouwangzhe.space expect { "(yes/no)" {send "yes\r"; exp_continue} "password:" {send "$psw\r"} } expect eof interact 语法是expect，自动化运维脚本，他的原理是在当前控制台开设一个新的控制台，然后监测命令行是否有你需要的命令，有的话就send一行命令+‘\r’，执行。 用expact还可以完成很多复杂的操作，例如推送博客到GitHub上去： #!/usr/bin/expect -f set gitPsw 123456 set userPsw 123456 spawn ssh root@localhost expect { "(yes/no)" {send "yes\r"; exp_continue} "password:" {send "$userPsw\r"} } expect "root@*" {send "cd /home/root/hexo\r"} expect "root@*" {send "hexo g\r"} expect "root@*" {send "hexo d\r"} expect "*passphrase*" {send "$gitPsw\r"} expect eof exit 0 效果就不展示了，就是省去了上传博客的过程，一步到位，有了这个技巧，就可以做很多方便的功能，也算是做到了优雅的开发了。 最后弄这套花了我一天的时间，摸索起来还是很费劲的，好在效果很好。最后，京紫镇楼。]]></content>
      <categories>
        <category>Utils</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2关于Junit的错误解决方法]]></title>
    <url>%2Farchives%2F63f8e5ec.html</url>
    <content type="text"><![CDATA[背景这段时间做的项目用到了RxJava2，整体框架为MVP。因为我公司的电脑差的厉害，没有硬件加速，项目环境起步就是5.0，所以只能用真机调试，公司的测试机比电脑还差，慢的要死，种种问题的压迫。我一拍脑门，决定Junit来进行测试我的P层逻辑，反正数据这种东西，测试通的过,到真机上面基本也就是刷新视图界面的问题了。 问题在整体coding的过程中还是遇到了部分棘手的问题，因为以往很少用Junit，应该说从来没有用过，所以踩了很多坑，我遇到的问题是在单元测试的过程中，无法用Rxjava2进行测试，而我MVP的主要核心就是Rxjava2，本文也主要是解决这个问题。 Rxjava2 &amp; Junit 引入依赖：dependencies { ... testImplementation 'junit:junit:4.12' implementation 'io.reactivex.rxjava2:rxjava:2.0.4' implementation 'io.reactivex.rxjava2:rxandroid:2.0.1' implementation 'com.google.code.gson:gson:2.8.2' } 注：因为我用的gradle版本比较高，所以‘compile’ 被 ‘implementation’取代了。junit应该是自带的，所以也可以不用引入。 Rxjava2 &amp; Presenter一个Rxjava的例子,因为我的项目是以MVP为基础的，所以这个demo也是以MVP为基础的，没有MVP基础的可以先去学一下，项目是简化了很多版的MVP框架。我先将我整个Demo给贴上，在叙述具体的问题解决方式。 目录结构 Presenter在Presenter层编写获取信息的代码，处理数据层信息，将结果反馈给视图层，以下是我Presenter层的代码: package com.qingheyang.testjr; //省略包 import ...; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/17 * describe: */ public class MainPresenter { MainActivity activity; public MainPresenter(MainActivity activity) { this.activity = activity; } /** * 获取user信息 */ public void getUser(final String path) { Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception { String json = HttpUtils.httpGet(path);//请求网络 if (json!=null) {//判断服务器返回数据是否为空 e.onNext(json); }else { e.onError(new Exception("获取user失败")); } } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { System.out.println(s);//因为junit输出日志不能用log，所以改用sys。 Gson gson = new Gson(); User user = gson.fromJson(s, User.class); //处理数据成功的话，交给activity的回调 activity.getDateSuccess(user); } @Override public void onError(Throwable e) { //失败交给activity给用户返回失败信息 activity.getDateFailed(0x001); } @Override public void onComplete() { } }); } } MainActivitypackage com.qingheyang.testjr; //省略包 import ...; public class MainActivity extends AppCompatActivity { private Button button; private MainPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initUi(); } private void initUi() { button = findViewById(R.id.main_btn); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { presenter.getUser(HttpUtils.URL);//地址要自己更换 } }); } /** * 成功的回调 * @param user */ public void getDateSuccess(User user){ //doSomethings... } /** * 失败的回调 * @param code */ public void getDateFailed(int code){ switch (code){ case 0x001: Toast.makeText(this, "获取信息失败", Toast.LENGTH_SHORT).show(); break; case 0x002: break; } } } HttpUtils工具类，因为是demo，获取方式为GET请求： package com.qingheyang.testjr; //省略包 import ...; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/17 * describe:http get请求 */ public class HttpUtils { //此处更换ip地址 public static final String URL = "http://192.168.1.1:8080"; public static String httpGet(String path) { URL url = null; HttpURLConnection conn = null; InputStream is = null; ByteArrayOutputStream baos = null; try { url = new URL(path); } catch (MalformedURLException e) { e.printStackTrace(); } if (url != null) { try { conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod("GET"); conn.setReadTimeout(8000); conn.setConnectTimeout(8000); conn.connect(); int responseCode = conn.getResponseCode(); if (responseCode == HttpURLConnection.HTTP_OK) { is = conn.getInputStream(); baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while (-1 != (len = is.read(buffer))) { baos.write(buffer, 0, len); baos.flush(); } is.close(); baos.close(); return baos.toString("utf-8"); } } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (baos != null) { try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } conn.disconnect(); } } return null; } } UserjavaBean: package com.qingheyang.testjr; import java.util.List; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/17 * describe: javaBean */ public class User { private List&lt;MessageInfoBean&gt; messageInfo; public List&lt;MessageInfoBean&gt; getMessageInfo() { return messageInfo; } public void setMessageInfo(List&lt;MessageInfoBean&gt; messageInfo) { this.messageInfo = messageInfo; } public static class MessageInfoBean { private String msg1; private String author; private String view; public String getMsg1() { return msg1; } public void setMsg1(String msg1) { this.msg1 = msg1; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getView() { return view; } public void setView(String view) { this.view = view; } } } Junit 如果你已经依赖了Junit了，请继续往下看，没有的话，我上面已经附上了依赖。 新建一个Presenter的单元测试类。在要测试的方法上面点击右键，选择goto，选择最后一个test。点击后出现Create New Test，点击。出现Create Test的对话框，勾选setUp，tearDown，以及你想测试的方法，getUser，点击OK。左边的列表中会出现刚才建立的MainPresenter。 test代码 package com.qingheyang.testjr; import org.junit.After; import org.junit.Before; import org.junit.Test; import static org.junit.Assert.*; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/18 * describe:MainPresenter的单元测试 */ public class MainPresenterTest { private MainPresenter presenter; @Before public void setUp() throws Exception { presenter = new MainPresenter(); } @After public void tearDown() throws Exception { presenter = null; } @Test public void getUser() { presenter.getUser(HttpUtils.URL); } } 以上就是rxjava+MVP的全部代码。当然这样肯定会出错的。顺便说一下，服务器搭建是Linux平台上面随便启动的一个tomcat服务器。 Run &amp; Error运行一下，单元测试的运行是在方法上面运行：可以点击左边的运行按钮，也可以对方法点击右键。运行过后会发现报错，原因一是因为部分Android的API，Junit不支持，没法做到完美支持，会报错。解决方法有两个。 依赖mock。 注释掉关于Android的代码。（我选择注释）也就是Rxjava中观察者中的onNext方法中关于Android的部分代码要注释。 @Override public void onNext(String s) { System.out.println(s);//因为junit输出日志不能用log，所以改用sys。 //Gson gson = new Gson(); // User user = gson.fromJson(s, User.class); //处理数据成功的话，交给activity的回调 //activity.getDateSuccess(user); } 再次运行。再次发现错误，也是我遇到的核心问题：Rxjava2在Junit中的线程问题，以及如何用API来解决它。 解决这个问题粗略的说一下其实也很简单，就是Rxjava2的子线程与主线程在电脑上面运行无法同步的问题。解决方法就是将子线程与安卓UI线程调整至同一线程即可。也搜索过很多网上的解决方法，基本都是Rxjava1的解决方法，Rxjava2的又一般是kotlin，直接上代码吧。 package com.qingheyang.testjr; //省略包 import ...; /** * 项目名称: * 类创建者:QHY. * 时间:2017/12/21 * 类说明: */ public class RxTools { public static void asyncToSync() { /** * 因为RxJava2已经没有了immediate线程，所以要自己做一个线 */ final Scheduler immediate = new Scheduler() { @Override public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { return super.scheduleDirect(run, 0, unit); } @Override public Worker createWorker() { return new ExecutorScheduler.ExecutorWorker(new ScheduledThreadPoolExecutor(1) { @Override public void execute(@NonNull Runnable runnable) { runnable.run(); } }); } }; /** * 将自己写的线程转换成为一个调度线程 */ Function&lt;Callable&lt;Scheduler&gt;, Scheduler&gt; schedulerFunc = new Function&lt;Callable&lt;Scheduler&gt;, Scheduler&gt;() { @Override public Scheduler apply(Callable&lt;Scheduler&gt; schedulerCallable) throws Exception { return immediate; } }; /** * 将单元测试的所有调度线程都统一一个线程 */ RxJavaPlugins.reset(); RxJavaPlugins.setInitIoSchedulerHandler(schedulerFunc); RxJavaPlugins.setInitComputationSchedulerHandler(schedulerFunc); RxJavaPlugins.setInitNewThreadSchedulerHandler(schedulerFunc); RxAndroidPlugins.reset(); RxAndroidPlugins.setInitMainThreadSchedulerHandler(schedulerFunc); } public static void resetPlugins(){ RxJavaPlugins.reset(); RxAndroidPlugins.reset(); } } 使用方法很简单，如下： @Before public void setUp() throws Exception { RxTools.asyncToSync(); presenter = new MainPresenter(); } @After public void tearDown() throws Exception { RxTools.resetPlugins(); presenter = null; } 在MainPresenterTest中，setUp以及tearDown中分别调整下代码即可。结果如下: 这个项目也可以在我的github中找到，如果有帮到你，欢迎给一个star。链接可以在主页GitHub图标获取。以上]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穿过一座京城来看你]]></title>
    <url>%2Farchives%2F9f083628.html</url>
    <content type="text"><![CDATA[穿过一座京城来看你 &emsp;&emsp; 一直想把那封信给你写完，却总是有各种各样的事情阻挡着，后来发现了，阻挡的事情叫做懒。&emsp;&emsp; 时光飞快，这已经是我们在一起的第五个年头了，1825个日日夜夜，截至到我写这个文字为止，是我们在一起第 1825 天 02 小时 38 分钟 39 秒。&emsp;&emsp; So..该从哪里说起呢？ 烟花三月去哪里&emsp;&emsp; 适逢16年的春天，正值毕业之际。那时候找工作不顺利的我，不知道将来该怎么发展的我，面对我们的爱情，更是觉得希望渺茫，当时也许不想认命的我真的认了命，觉得我们不合适，觉得我们在一起的结果是错误的,可能我会后悔一辈子。&emsp;&emsp; 也许我会回家做做小生意，你呢，做一个小公务员吗？这些那时候我都想过。&emsp;&emsp; 当然，结果也不是那么写的，那时候虽然我们都对未来很没有信心，可是怎么会难得倒两个有识青年的思想呢。&emsp;&emsp; 俗话说的好，劳动人民的智慧是伟大的。&emsp;&emsp; 我想我们是最不擅长守株待兔，不，是坐以待毙的种人吧，终于在一个夜晚，初春的夜晚，两个人想了又想，看了又看。&emsp;&emsp; 你说，要不出去试试看？&emsp;&emsp; 我说，好啊。&emsp;&emsp; 烟花三月去哪里？&emsp;&emsp; 那就…去京城吧。 Sealed With A Kiss&emsp;&emsp; 我的征途，是星辰大海。&emsp;&emsp; 上面那句话是我离开天津的时候最后一条朋友圈，那个时候我心怀大志，也是被拒了太多次，想要急于证明自己的话吧，勾践卧薪尝胆，我没有苦胆可以常，反倒是有一个对自己不离不弃的姑娘陪着我，我想我是幸福的，我想我们也终是会幸福的。&emsp;&emsp; 很快便进入了初夏，天气一点点的热了起来，我的心也慢慢的燥了起来。&emsp;&emsp; 有幸你能心里念着我，來北京几次，大概，人生中最幸福的那种时光不外乎如此，一个人在陌生的城市，却总能见到最爱的人，这下，连我自己也不敢说我的青春很惨了。&emsp;&emsp; 但是，重逢总是伴随着离去，巨大的幸福，当然伴随着巨大的失落。&emsp;&emsp; 亲爱的，把你送出北京的时候，我想，我哭了… &emsp;&emsp; 离开火车站的时候，我狠狠的想，这辈子，老子绝对不要体验第二次异地恋！&emsp;&emsp; 不知道我们彼此去看了多少次对方，但是火车票我都留着，已经数不清多少张了，就是这样的车票：&emsp;&emsp; 那时候住在北京的回龙观，同北京无数的小青年一样，都在努力的生存着，回龙观那边距北京南站有近两个小时的车程，所以，真的就是&emsp;&emsp; 穿过一座京城来看你。 行歌&emsp;&emsp; 记得那个仲夏的夜晚，披星戴月的我回到了天津工大，原因只有一个，我要毕业了。&emsp;&emsp; 挥一挥衣袖，告别了我们青春最后的时光，也看到了我们青春最后的样子。&emsp;&emsp; 临毕业之前，因为毕业设计的缘故，我也回了学校很多次，感受着离开了几个月的校园，那个时候突然感到了很不适应，说的准确一点是无所适从，习惯了不会断电，习惯了外面的高额饭菜，习惯了省水省电，回来，真的有点陌生。&emsp;&emsp; 后来发现，陌生的不是校园，是我，从离开北京的那个时间起，我就摆脱了学生这个称呼，这么说，我岂不是老牛吃嫩草，把你给吃了。&emsp;&emsp; 那段时间仔仔细细的又和你走了一遍校园，拿着拍立得，到处拍下照片，拍到的好看的照片全部被我拿走了（很不好意思的是，在北京搬家的时候弄丢了几张），我们一边感叹着时间的飞快，一面面对着未来充满忐忑。 &emsp;&emsp; 不过我们能确定的是，没什么能把我们分开。&emsp;&emsp; 那是我们在一起的第四个年头，也是我们上大学的第四年。 &emsp;&emsp; 我很荣幸&emsp;&emsp; 有你陪伴着我&emsp;&emsp; 度过了&emsp;&emsp; 人生中&emsp;&emsp; 最美好&emsp;&emsp; 的那四年。 &emsp;&emsp; 也很庆幸四年的结果不是悲伤的，我们没有为青春的逝去而感到悲伤满怀，也没有因为一次次的矛盾而弃对方而去。&emsp;&emsp; 虽然我们也会开始满怀心事，也会绕过从前的轻狂，不在大声欢笑大声哭泣。&emsp;&emsp; 毕竟，万物生长，你我怎么会长不大？&emsp;&emsp; 毕业季，来了。&emsp;&emsp; 我们，还在一起。 前前前前世&emsp;&emsp; 毕业季，走了。&emsp;&emsp; 我在北京也算是正式落定了，我想我们两个九九八十一难，算是该走向一个不错的方向了吧。&emsp;&emsp; 开始了工作的我，每天上下班大概一共需要三个小时，从四惠，到回龙观东大街，中间要历经霍营，永泰庄，北土城，南锣鼓巷，还有什么站我也给忘了。&emsp;&emsp; 就像立花泷一样，开始在一个偌大的北京城开始我的足迹，当然，我没有立花泷那样帅，他在的东京也跟我的北京不一样，起码，东京没有霾。&emsp;&emsp; 我们两个，也正式进入了下一个阶段，得考虑以后的日子了，以后的什么日子呢？当然，就是以后的日子啦。&emsp;&emsp; 以后的日子就是，谈！婚！论！嫁！&emsp;&emsp; 对，我们开始计划着见家长，计划着什么时候买房子。计划着什么时候开始真正有我们自己的生活。&emsp;&emsp; 生活踏入正轨的好处就是终于不在过着动荡不安的日子。&emsp;&emsp; 终于再某个风和日丽的中秋节，我去见了你的父母，对我很好的两个长辈。&emsp;&emsp; 同样再某个秋高气爽的十月一，你来到了我的故乡，见到我的父母，两个对你很好的长辈。&emsp;&emsp; 我从来没有想过能把你领到我曾经生活了十几年的小城市，去走一走我走过无数遍的路，我上下学走了无数遍的路，去见一见跟我认识十几年的朋友。&emsp;&emsp; 世界就是这么奇妙，我们曾不被任何人看好，我们曾被很多人打击，可是我们就是这么过来了，见到了双方的家长，定下了我们约定一生的约定。&emsp;&emsp; 虽然一切都像是很顺利的模样，可是中间是是非曲直，你是明白的吧。 天津不太热&emsp;&emsp; 经历了这么多之后，生活似乎觉得我们还是太顺利了，终归是给我出了个大难题。&emsp;&emsp; 在北京的公司倒闭了，我想我又一次遇到了危机。。。&emsp;&emsp; 没有工作的日子很难过，经常的就是一下午的发呆，努力去找工作，努力去放松自己，总是会想着，怎么会这样。&emsp;&emsp; 在艰难的日子里面，生活总是喜欢给你没事找点事，例如，姥爷病逝了…&emsp;&emsp; 凌晨三点得到的消息，走了，不知道该怎么说，你很担心我，甚至一度要求跟我一起回家，真的，心里很安心。&emsp;&emsp; 未来的一段日子，我都再浑浑噩噩的度过，不知道该怎么办，不知道能不能撑得起來。&emsp;&emsp; 亲爱的，感谢你在我最难过的时候支撑着我，度过每一个日日夜夜。&emsp;&emsp; 既然，北京不留爷，爷就走吧。&emsp;&emsp; 同样挥一挥衣袖，不留一丝痕迹，告别窄小的出租屋，告别3小时的上下班，亲爱的北京，你最后用你的大霾天给我留下了一个深情的吻别。&emsp;&emsp; 北京太热，五月流火，我该去哪里？&emsp;&emsp; 你说，回来吧。&emsp;&emsp; 我说，好。&emsp;&emsp; 夏时梦长，梦长自然要你在身旁。&emsp;&emsp; 时隔一年零两个月，我又回来了。 穿过一座京城来看你&emsp;&emsp; 來到熟悉的天津的时候，我还是很不适应，不过，生活倒是容易多了。&emsp;&emsp; 一周一次的固定见面，再也没有那种舟车劳顿的奔波感。&emsp;&emsp; 终于在一次偶然的面试，我找到了合适的工作，幸不辱命。&emsp;&emsp; 在拿到offer的那个时候，我终于心里面释然了，我终于没有让你和你们失望。&emsp;&emsp; 经几场圆滑换锋芒。 &emsp;&emsp; 说了太多我自己了，以至于我都忘记了我们的感情是什么时候开始变得更加牢固，更加让我们分不开。&emsp;&emsp; 也许是我们一起努力学习的时候，也许是我们一起算计这个月还有多少积蓄的时候，又或者我们研究什么假期有空回家的时候。&emsp;&emsp; 很多逝去都是轻描淡写的过去了，但是我知道，心里刻上的痕迹才不会那么轻易抹平。&emsp;&emsp; 烟花三月去京城，五月流火回天津。&emsp;&emsp; 我终于，穿过一整座京城，回到了你身边。 后记&emsp;&emsp; 其实我想说的MarkDown语法编辑器真的很难用，好不容自己搭了个博客，却要用MD來写着文章。表示很难受。 &emsp;&emsp;谨以此文章献给跟了我整整五年的杨丹小姐，感谢你的付出，希望日后我们能够更加相亲相爱， 不离不弃。 &emsp;&emsp; 以上。]]></content>
      <categories>
        <category>New Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远离CSDN，远离简书]]></title>
    <url>%2Farchives%2Fca3c53dd.html</url>
    <content type="text"><![CDATA[终于建立了自己的小站啦，鄙站不大，但是总算是一段时间的技术总结。最近也发布了第一篇文章，今天调整了下样式结构，感觉还是蛮开心的。总之呢，也算是做到了当初的一个小愿望了吧。感谢我强力的技术支持，国哥，帮我完成一系列的自动化运维推送脚本。 想想后来，我也会加上评论功能吧，现在的评论功能都太弱鸡了，必须要github账号，实在是不太好弄。 感谢您能抽出时间阅读我的博客。]]></content>
      <categories>
        <category>New Life</category>
      </categories>
      <tags>
        <tag>my life</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于互联网技术]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%85%B3%E4%BA%8E%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[互联网技术 前端：android\ios，react，jsp，vue。 后端：java js .net C#。 dba：mysql oracle mangodb。 运维：windows server 、 linux 、 tomcat 、Apache 、nginx、docker。 new tech. : hadoop、tensorflow、caffe。 混合：react native 、pwa。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于机器学习的一些想法(持续更新中)]]></title>
    <url>%2F2018%2F05%2F23%2FUntitled%2F</url>
    <content type="text"><![CDATA[我现在的情况是处在半迷茫阶段了。我已经24了，今年结的婚，算是结婚尚早的。不提个人生活，我在工作上面也存在很大的迷茫，不知道该往哪个方向走。前段日子定下了走人工智能，这算是我自主学习的半年来定下的结果吧。 现在在学习人工智能，罗列一下现在掌握的信息： 人工智能的本质是模型。 模型有很多，需要自己来通过高等数学来编写。 框架是tensorflow，或者caffe。 tensorflow需要用到的是python。 目前刚刚学习了决策树。 损失函数、激活函数。 卷积CNN原理，降维、反向传播、共享权值、纹理。 其实想学人工智能这个方面也跟我小时候的执念有关，哪个孩子心底不存在一个人工智能的梦啊。既然父母把我放出来了，我就不想着去做生意了，我要选择的不是一个三流的执行工程师，而是一个真正的工程师。]]></content>
      <categories>
        <category>New Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Mac打造一个顺手的链接Linux工具]]></title>
    <url>%2F2018%2F03%2F15%2F%E4%B8%BAMac%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E9%A1%BA%E6%89%8B%E7%9A%84%E9%93%BE%E6%8E%A5Linux%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[背景Mac的话也买了有一段时间，2017款的，作为一个Android程序员，虽然买苹果的本子会让人觉得有种投敌的感觉，但是不得不说，真的实在是太好用了。作为一个Android程序员，怎么能离开Linux呢？无论是NDK还是.so库的编译，再到ffmpeg，都需要用到Linux。因为朋友的关系，我对Linux还算比较熟悉，能够使用基本的命令，cd ，ls -al，htop这些命令就不说了，makefile也写过部分，脚本也写过一部分，不过应用场景较少罢了。那么问题就来了，与Linux同源的Mac OS会不会对Linux开发有着更好的支持。 环境 Linux服务器：Ubuntu 16.04 服务器：用的机器是一台老联想，8G内存，i5cpu，256 SSD 域名：www.shouwangzhe.space (大佬不要攻击我,现在已经更换了) MacBookPro: Mac OS 工具:Shuttle 解释一下为什么不用阿里云：之所以没有选择阿里云服务器，主要因为是觉得没必要，1Mb的速度，1G内存，1核cpu，一个月100多，何必呢？ 效果效果基本是很傻瓜的一种方式，顶部的图标点击后，选择哪个操作，选择登陆远程服务器:然后就会蹦出控制台的窗口:然后我们就能愉快的ls了。或许你觉得这个有什么意思，用命令不还是能解决吗，打开控制台，输入： ssh -p 22 xxx@www.域名.com #输入密码 不一样能进去吗？如果遇到复杂问题，例如你想把自己的hexo博客推送到githup.io上去呢。 #首先要 xxx@Lenovo-IdeaPad-Y480:~$ cd /hexo #然后1 xxx@Lenovo-IdeaPad-Y480:~/hexo$ hexo g #然后2 xxx@Lenovo-IdeaPad-Y480:~/hexo$ hexo d #然后3 输入你git的本地密码 Enter passphrase for key '/home/star/.ssh/id_rsa': xxxxxx #推送成功 所以我觉得自动化还是挺重要的,点击一下，一步到位。 实现实现的方式也是，会的不难，难的不会，基本是由两部分组成，Linux的expact命令，以及Shuttle。 ShuttleShuttle 是一款图形界面化的cmd命令工具。下载完后点击图标，就可以在顶部的导航栏找到他了，至于怎么用，点击这个按钮:会打开一个文档，json格式的，也就是软件的配置文件(缩进好像有点问题)： { "_comments": [], "editor": "default", "launch_at_login": false, "terminal": "Terminal.app", "iTerm_version": "nightly", "default_theme": "Ocean", "open_in": "new", "show_ssh_config_hosts": false, "ssh_config_ignore_hosts": [], "ssh_config_ignore_keywords": [], "hosts": [ { "linux Servers": [ { "QHY’s linux Servers": [ { "cmd": ".//linux自动脚本/login.sh", "inTerminal": "tab", "name": "login", "theme": "Ocean", "title": "ShouWangZhe" } ] }, { "博客运维脚本": [ { "cmd": ".//linux自动脚本/starHexoBlog.sh", "inTerminal": "tab", "name": "长时启动博客服务器", "theme": "Ocean", "title": "ShouWangZhe" }, { "cmd": ".//linux自动脚本/starHexoBlog-RealTime.sh", "inTerminal": "tab", "name": "实时启动博客服务器", "theme": "Ocean", "title": "ShouWangZhe" }, { "cmd": ".//linux自动脚本/endHexoBlog.sh", "inTerminal": "tab", "name": "关闭博客服务器", "theme": "Ocean", "title": "ShouWangZhe" } ] } ] }, { "Android adb Servers": [ { "QHY’s Home adb Servers": [ { "cmd": "adb connect 192.168.10.211:5555\r exit\r", "inTerminal": "tab", "name": "connect home onplus 2 test", "theme": "Homebrew", "title": "ShouWangZhe 1+" }, { "cmd": "adb disconnect 192.168.10.211:5555\r exit\r", "inTerminal": "tab", "name": "disconnect home onplus 2", "theme": "Homebrew", "title": "ShouWangZhe 1+" } ] } ] } ] } 上面的是我的配置，解析一下这个json：也就是对应我的效果那节的那个图，配置文件中的host节点是我们要用到的节点，有点编程基础的也知道这个节点是一个JsonArray。下面可以加很多节点，每一个节点都是一级菜单，大体目录就这么多，每个节点的配置如下： { "cmd": ".//linux自动脚本/login.sh", "inTerminal": "tab", "name": "login", "theme": "Ocean", "title": "ShouWangZhe" } cmd：你要在打开的控制台里面输入什么命令。 name：标题。 theme：Mac控制台主题，我选的是Ocean。 title：Mac控制台标题。 我是一个android工程师，所以偶尔也需要wifi ADB操作，同样可以写在配置里面： { "cmd": "adb connect 192.168.10.211:5555\r exit\r", "inTerminal": "tab", "name": "connect home onplus 2 test", "theme": "Homebrew", "title": "ShouWangZhe 1+" } 效果就是这样的：以上大体就是Shuttle的应用，它就是读取cmd节点的命令，然后执行。 expact很明显，上面的命令我输入了执行脚本的命令。 .//linux自动脚本/login.sh 我在Mac目录下面建立了“linux自动脚本”这个文件夹，专门用来存放我的脚本。例如想要登陆远程服务器的脚本(login.sh)内容如下： #!/usr/bin/expect -f set psw 123456 spawn ssh -p 22 root@www.shouwangzhe.space expect { "(yes/no)" {send "yes\r"; exp_continue} "password:" {send "$psw\r"} } expect eof interact 语法是expect，自动化运维脚本，他的原理是在当前控制台开设一个新的控制台，然后监测命令行是否有你需要的命令，有的话就send一行命令+‘\r’，执行。 用expact还可以完成很多复杂的操作，例如推送博客到GitHub上去： #!/usr/bin/expect -f set gitPsw 123456 set userPsw 123456 spawn ssh root@localhost expect { "(yes/no)" {send "yes\r"; exp_continue} "password:" {send "$userPsw\r"} } expect "root@*" {send "cd /home/root/hexo\r"} expect "root@*" {send "hexo g\r"} expect "root@*" {send "hexo d\r"} expect "*passphrase*" {send "$gitPsw\r"} expect eof exit 0 效果就不展示了，就是省去了上传博客的过程，一步到位，有了这个技巧，就可以做很多方便的功能，也算是做到了优雅的开发了。 最后弄这套花了我一天的时间，摸索起来还是很费劲的，好在效果很好。最后，京紫镇楼。]]></content>
      <categories>
        <category>Utils</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2关于Junit的错误解决方法]]></title>
    <url>%2F2018%2F02%2F07%2FRxJava2%E5%85%B3%E4%BA%8EJunit%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景这段时间做的项目用到了RxJava2，整体框架为MVP。因为我公司的电脑差的厉害，没有硬件加速，项目环境起步就是5.0，所以只能用真机调试，公司的测试机比电脑还差，慢的要死，种种问题的压迫。我一拍脑门，决定Junit来进行测试我的P层逻辑，反正数据这种东西，测试通的过,到真机上面基本也就是刷新视图界面的问题了。 问题在整体coding的过程中还是遇到了部分棘手的问题，因为以往很少用Junit，应该说从来没有用过，所以踩了很多坑，我遇到的问题是在单元测试的过程中，无法用Rxjava2进行测试，而我MVP的主要核心就是Rxjava2，本文也主要是解决这个问题。 Rxjava2 &amp; Junit 引入依赖：dependencies { ... testImplementation 'junit:junit:4.12' implementation 'io.reactivex.rxjava2:rxjava:2.0.4' implementation 'io.reactivex.rxjava2:rxandroid:2.0.1' implementation 'com.google.code.gson:gson:2.8.2' } 注：因为我用的gradle版本比较高，所以‘compile’ 被 ‘implementation’取代了。junit应该是自带的，所以也可以不用引入。 Rxjava2 &amp; Presenter一个Rxjava的例子,因为我的项目是以MVP为基础的，所以这个demo也是以MVP为基础的，没有MVP基础的可以先去学一下，项目是简化了很多版的MVP框架。我先将我整个Demo给贴上，在叙述具体的问题解决方式。 目录结构 Presenter在Presenter层编写获取信息的代码，处理数据层信息，将结果反馈给视图层，以下是我Presenter层的代码: package com.qingheyang.testjr; //省略包 import ...; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/17 * describe: */ public class MainPresenter { MainActivity activity; public MainPresenter(MainActivity activity) { this.activity = activity; } /** * 获取user信息 */ public void getUser(final String path) { Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception { String json = HttpUtils.httpGet(path);//请求网络 if (json!=null) {//判断服务器返回数据是否为空 e.onNext(json); }else { e.onError(new Exception("获取user失败")); } } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { System.out.println(s);//因为junit输出日志不能用log，所以改用sys。 Gson gson = new Gson(); User user = gson.fromJson(s, User.class); //处理数据成功的话，交给activity的回调 activity.getDateSuccess(user); } @Override public void onError(Throwable e) { //失败交给activity给用户返回失败信息 activity.getDateFailed(0x001); } @Override public void onComplete() { } }); } } MainActivitypackage com.qingheyang.testjr; //省略包 import ...; public class MainActivity extends AppCompatActivity { private Button button; private MainPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initUi(); } private void initUi() { button = findViewById(R.id.main_btn); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { presenter.getUser(HttpUtils.URL);//地址要自己更换 } }); } /** * 成功的回调 * @param user */ public void getDateSuccess(User user){ //doSomethings... } /** * 失败的回调 * @param code */ public void getDateFailed(int code){ switch (code){ case 0x001: Toast.makeText(this, "获取信息失败", Toast.LENGTH_SHORT).show(); break; case 0x002: break; } } } HttpUtils工具类，因为是demo，获取方式为GET请求： package com.qingheyang.testjr; //省略包 import ...; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/17 * describe:http get请求 */ public class HttpUtils { //此处更换ip地址 public static final String URL = "http://192.168.1.1:8080"; public static String httpGet(String path) { URL url = null; HttpURLConnection conn = null; InputStream is = null; ByteArrayOutputStream baos = null; try { url = new URL(path); } catch (MalformedURLException e) { e.printStackTrace(); } if (url != null) { try { conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod("GET"); conn.setReadTimeout(8000); conn.setConnectTimeout(8000); conn.connect(); int responseCode = conn.getResponseCode(); if (responseCode == HttpURLConnection.HTTP_OK) { is = conn.getInputStream(); baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while (-1 != (len = is.read(buffer))) { baos.write(buffer, 0, len); baos.flush(); } is.close(); baos.close(); return baos.toString("utf-8"); } } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (baos != null) { try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } conn.disconnect(); } } return null; } } UserjavaBean: package com.qingheyang.testjr; import java.util.List; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/17 * describe: javaBean */ public class User { private List&lt;MessageInfoBean&gt; messageInfo; public List&lt;MessageInfoBean&gt; getMessageInfo() { return messageInfo; } public void setMessageInfo(List&lt;MessageInfoBean&gt; messageInfo) { this.messageInfo = messageInfo; } public static class MessageInfoBean { private String msg1; private String author; private String view; public String getMsg1() { return msg1; } public void setMsg1(String msg1) { this.msg1 = msg1; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getView() { return view; } public void setView(String view) { this.view = view; } } } Junit 如果你已经依赖了Junit了，请继续往下看，没有的话，我上面已经附上了依赖。 新建一个Presenter的单元测试类。在要测试的方法上面点击右键，选择goto，选择最后一个test。 点击后出现Create New Test，点击。 出现Create Test的对话框，勾选setUp，tearDown，以及你想测试的方法，getUser，点击OK。 左边的列表中会出现刚才建立的MainPresenter。 test代码 package com.qingheyang.testjr; import org.junit.After; import org.junit.Before; import org.junit.Test; import static org.junit.Assert.*; /** * project: TestJR * package: com.qingheyang.testjr * creater: qingheyang * date: 2018/2/18 * describe:MainPresenter的单元测试 */ public class MainPresenterTest { private MainPresenter presenter; @Before public void setUp() throws Exception { presenter = new MainPresenter(); } @After public void tearDown() throws Exception { presenter = null; } @Test public void getUser() { presenter.getUser(HttpUtils.URL); } } 以上就是rxjava+MVP的全部代码。当然这样肯定会出错的。顺便说一下，服务器搭建是Linux平台上面随便启动的一个tomcat服务器。 Run &amp; Error运行一下，单元测试的运行是在方法上面运行：可以点击左边的运行按钮，也可以对方法点击右键。运行过后会发现报错，原因一是因为部分Android的API，Junit不支持，没法做到完美支持，会报错。解决方法有两个。 依赖mock。 注释掉关于Android的代码。（我选择注释）也就是Rxjava中观察者中的onNext方法中关于Android的部分代码要注释。 @Override public void onNext(String s) { System.out.println(s);//因为junit输出日志不能用log，所以改用sys。 //Gson gson = new Gson(); // User user = gson.fromJson(s, User.class); //处理数据成功的话，交给activity的回调 //activity.getDateSuccess(user); } 再次运行。再次发现错误，也是我遇到的核心问题：Rxjava2在Junit中的线程问题，以及如何用API来解决它。 解决这个问题粗略的说一下其实也很简单，就是Rxjava2的子线程与主线程在电脑上面运行无法同步的问题。解决方法就是将子线程与安卓UI线程调整至同一线程即可。也搜索过很多网上的解决方法，基本都是Rxjava1的解决方法，Rxjava2的又一般是kotlin，直接上代码吧。 package com.qingheyang.testjr; //省略包 import ...; /** * 项目名称: * 类创建者:QHY. * 时间:2017/12/21 * 类说明: */ public class RxTools { public static void asyncToSync() { /** * 因为RxJava2已经没有了immediate线程，所以要自己做一个线 */ final Scheduler immediate = new Scheduler() { @Override public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { return super.scheduleDirect(run, 0, unit); } @Override public Worker createWorker() { return new ExecutorScheduler.ExecutorWorker(new ScheduledThreadPoolExecutor(1) { @Override public void execute(@NonNull Runnable runnable) { runnable.run(); } }); } }; /** * 将自己写的线程转换成为一个调度线程 */ Function&lt;Callable&lt;Scheduler&gt;, Scheduler&gt; schedulerFunc = new Function&lt;Callable&lt;Scheduler&gt;, Scheduler&gt;() { @Override public Scheduler apply(Callable&lt;Scheduler&gt; schedulerCallable) throws Exception { return immediate; } }; /** * 将单元测试的所有调度线程都统一一个线程 */ RxJavaPlugins.reset(); RxJavaPlugins.setInitIoSchedulerHandler(schedulerFunc); RxJavaPlugins.setInitComputationSchedulerHandler(schedulerFunc); RxJavaPlugins.setInitNewThreadSchedulerHandler(schedulerFunc); RxAndroidPlugins.reset(); RxAndroidPlugins.setInitMainThreadSchedulerHandler(schedulerFunc); } public static void resetPlugins(){ RxJavaPlugins.reset(); RxAndroidPlugins.reset(); } } 使用方法很简单，如下： @Before public void setUp() throws Exception { RxTools.asyncToSync(); presenter = new MainPresenter(); } @After public void tearDown() throws Exception { RxTools.resetPlugins(); presenter = null; } 在MainPresenterTest中，setUp以及tearDown中分别调整下代码即可。结果如下: 这个项目也可以在我的github中找到，如果有帮到你，欢迎给一个star。链接可以在下方GitHub图标获取。以上]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穿过一座京城来看你]]></title>
    <url>%2F2018%2F01%2F04%2F%E7%A9%BF%E8%BF%87%E4%B8%80%E5%BA%A7%E4%BA%AC%E5%9F%8E%E6%9D%A5%E7%9C%8B%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[穿过一座京城来看你 &emsp;&emsp; 一直想把那封信给你写完，却总是有各种各样的事情阻挡着，后来发现了，阻挡的事情叫做懒。&emsp;&emsp; 时光飞快，这已经是我们在一起的第五个年头了，1825个日日夜夜，截至到我写这个文字为止，是我们在一起第 1825 天 02 小时 38 分钟 39 秒。&emsp;&emsp; So..该从哪里说起呢？ 烟花三月去哪里&emsp;&emsp; 适逢16年的春天，正值毕业之际。那时候找工作不顺利的我，不知道将来该怎么发展的我，面对我们的爱情，更是觉得希望渺茫，当时也许不想认命的我真的认了命，觉得我们不合适，觉得我们在一起的结果是错误的,可能我会后悔一辈子。&emsp;&emsp; 也许我会回家做做小生意，你呢，做一个小公务员吗？这些那时候我都想过。&emsp;&emsp; 当然，结果也不是那么写的，那时候虽然我们都对未来很没有信心，可是怎么会难得倒两个有识青年的思想呢。&emsp;&emsp; 俗话说的好，劳动人民的智慧是伟大的。&emsp;&emsp; 我想我们是最不擅长守株待兔，不，是坐以待毙的种人吧，终于在一个夜晚，初春的夜晚，两个人想了又想，看了又看。&emsp;&emsp; 你说，要不出去试试看？&emsp;&emsp; 我说，好啊。&emsp;&emsp; 烟花三月去哪里？&emsp;&emsp; 那就…去京城吧。 Sealed With A Kiss&emsp;&emsp; 我的征途，是星辰大海。&emsp;&emsp; 上面那句话是我离开天津的时候最后一条朋友圈，那个时候我心怀大志，也是被拒了太多次，想要急于证明自己的话吧，勾践卧薪尝胆，我没有苦胆可以常，反倒是有一个对自己不离不弃的姑娘陪着我，我想我是幸福的，我想我们也终是会幸福的。&emsp;&emsp; 很快便进入了初夏，天气一点点的热了起来，我的心也慢慢的燥了起来。&emsp;&emsp; 有幸你能心里念着我，來北京几次，大概，人生中最幸福的那种时光不外乎如此，一个人在陌生的城市，却总能见到最爱的人，这下，连我自己也不敢说我的青春很惨了。&emsp;&emsp; 但是，重逢总是伴随着离去，巨大的幸福，当然伴随着巨大的失落。&emsp;&emsp; 亲爱的，把你送出北京的时候，我想，我哭了… &emsp;&emsp; 离开火车站的时候，我狠狠的想，这辈子，老子绝对不要体验第二次异地恋！&emsp;&emsp; 不知道我们彼此去看了多少次对方，但是火车票我都留着，已经数不清多少张了，就是这样的车票： &emsp;&emsp; 那时候住在北京的回龙观，同北京无数的小青年一样，都在努力的生存着，回龙观那边距北京南站有近两个小时的车程，所以，真的就是&emsp;&emsp; 穿过一座京城来看你。 行歌&emsp;&emsp; 记得那个仲夏的夜晚，披星戴月的我回到了天津工大，原因只有一个，我要毕业了。&emsp;&emsp; 挥一挥衣袖，告别了我们青春最后的时光，也看到了我们青春最后的样子。&emsp;&emsp; 临毕业之前，因为毕业设计的缘故，我也回了学校很多次，感受着离开了几个月的校园，那个时候突然感到了很不适应，说的准确一点是无所适从，习惯了不会断电，习惯了外面的高额饭菜，习惯了省水省电，回来，真的有点陌生。&emsp;&emsp; 后来发现，陌生的不是校园，是我，从离开北京的那个时间起，我就摆脱了学生这个称呼，这么说，我岂不是老牛吃嫩草，把你给吃了。&emsp;&emsp; 那段时间仔仔细细的又和你走了一遍校园，拿着拍立得，到处拍下照片，拍到的好看的照片全部被我拿走了（很不好意思的是，在北京搬家的时候弄丢了几张），我们一边感叹着时间的飞快，一面面对着未来充满忐忑。 &emsp;&emsp; 不过我们能确定的是，没什么能把我们分开。&emsp;&emsp; 那是我们在一起的第四个年头，也是我们上大学的第四年。 &emsp;&emsp; 我很荣幸&emsp;&emsp; 有你陪伴着我&emsp;&emsp; 度过了&emsp;&emsp; 人生中&emsp;&emsp; 最美好&emsp;&emsp; 的那四年。 &emsp;&emsp; 也很庆幸四年的结果不是悲伤的，我们没有为青春的逝去而感到悲伤满怀，也没有因为一次次的矛盾而弃对方而去。&emsp;&emsp; 虽然我们也会开始满怀心事，也会绕过从前的轻狂，不在大声欢笑大声哭泣。&emsp;&emsp; 毕竟，万物生长，你我怎么会长不大？&emsp;&emsp; 毕业季，来了。&emsp;&emsp; 我们，还在一起。 前前前前世&emsp;&emsp; 毕业季，走了。&emsp;&emsp; 我在北京也算是正式落定了，我想我们两个九九八十一难，算是该走向一个不错的方向了吧。&emsp;&emsp; 开始了工作的我，每天上下班大概一共需要三个小时，从四惠，到回龙观东大街，中间要历经霍营，永泰庄，北土城，南锣鼓巷，还有什么站我也给忘了。&emsp;&emsp; 就像立花泷一样，开始在一个偌大的北京城开始我的足迹，当然，我没有立花泷那样帅，他在的东京也跟我的北京不一样，起码，东京没有霾。&emsp;&emsp; 我们两个，也正式进入了下一个阶段，得考虑以后的日子了，以后的什么日子呢？当然，就是以后的日子啦。&emsp;&emsp; 以后的日子就是，谈！婚！论！嫁！&emsp;&emsp; 对，我们开始计划着见家长，计划着什么时候买房子。计划着什么时候开始真正有我们自己的生活。&emsp;&emsp; 生活踏入正轨的好处就是终于不在过着动荡不安的日子。&emsp;&emsp; 终于再某个风和日丽的中秋节，我去见了你的父母，对我很好的两个长辈。&emsp;&emsp; 同样再某个秋高气爽的十月一，你来到了我的故乡，见到我的父母，两个对你很好的长辈。&emsp;&emsp; 我从来没有想过能把你领到我曾经生活了十几年的小城市，去走一走我走过无数遍的路，我上下学走了无数遍的路，去见一见跟我认识十几年的朋友。&emsp;&emsp; 世界就是这么奇妙，我们曾不被任何人看好，我们曾被很多人打击，可是我们就是这么过来了，见到了双方的家长，定下了我们约定一生的约定。&emsp;&emsp; 虽然一切都像是很顺利的模样，可是中间是是非曲直，你是明白的吧。 天津不太热&emsp;&emsp; 经历了这么多之后，生活似乎觉得我们还是太顺利了，终归是给我出了个大难题。&emsp;&emsp; 在北京的公司倒闭了，我想我又一次遇到了危机。。。&emsp;&emsp; 没有工作的日子很难过，经常的就是一下午的发呆，努力去找工作，努力去放松自己，总是会想着，怎么会这样。&emsp;&emsp; 在艰难的日子里面，生活总是喜欢给你没事找点事，例如，姥爷病逝了…&emsp;&emsp; 凌晨三点得到的消息，走了，不知道该怎么说，你很担心我，甚至一度要求跟我一起回家，真的，心里很安心。&emsp;&emsp; 未来的一段日子，我都再浑浑噩噩的度过，不知道该怎么办，不知道能不能撑得起來。&emsp;&emsp; 亲爱的，感谢你在我最难过的时候支撑着我，度过每一个日日夜夜。&emsp;&emsp; 既然，北京不留爷，爷就走吧。&emsp;&emsp; 同样挥一挥衣袖，不留一丝痕迹，告别窄小的出租屋，告别3小时的上下班，亲爱的北京，你最后用你的大霾天给我留下了一个深情的吻别。&emsp;&emsp; 北京太热，五月流火，我该去哪里？&emsp;&emsp; 你说，回来吧。&emsp;&emsp; 我说，好。&emsp;&emsp; 夏时梦长，梦长自然要你在身旁。&emsp;&emsp; 时隔一年零两个月，我又回来了。 穿过一座京城来看你&emsp;&emsp; 來到熟悉的天津的时候，我还是很不适应，不过，生活倒是容易多了。&emsp;&emsp; 一周一次的固定见面，再也没有那种舟车劳顿的奔波感。&emsp;&emsp; 终于在一次偶然的面试，我找到了合适的工作，幸不辱命。&emsp;&emsp; 在拿到offer的那个时候，我终于心里面释然了，我终于没有让你和你们失望。&emsp;&emsp; 经几场圆滑换锋芒。 &emsp;&emsp; 说了太多我自己了，以至于我都忘记了我们的感情是什么时候开始变得更加牢固，更加让我们分不开。&emsp;&emsp; 也许是我们一起努力学习的时候，也许是我们一起算计这个月还有多少积蓄的时候，又或者我们研究什么假期有空回家的时候。&emsp;&emsp; 很多逝去都是轻描淡写的过去了，但是我知道，心里刻上的痕迹才不会那么轻易抹平。&emsp;&emsp; 烟花三月去京城，五月流火回天津。&emsp;&emsp; 我终于，穿过一整座京城，回到了你身边。 后记&emsp;&emsp; 其实我想说的MarkDown语法编辑器真的很难用，好不容自己搭了个博客，却要用MD來写着文章。表示很难受。 &emsp;&emsp;谨以此文章献给跟了我整整五年的杨丹小姐，感谢你的付出，希望日后我们能够更加相亲相爱， 不离不弃。 &emsp;&emsp; 以上。]]></content>
      <categories>
        <category>New Life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远离CSDN，远离简书]]></title>
    <url>%2F2018%2F01%2F01%2F%E8%BF%9C%E7%A6%BBCSDN%EF%BC%8C%E8%BF%9C%E7%A6%BB%E7%AE%80%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[终于建立了自己的小站啦，鄙站不大，但是总算是一段时间的技术总结。最近也发布了第一篇文章，今天调整了下样式结构，感觉还是蛮开心的。总之呢，也算是做到了当初的一个小愿望了吧。感谢我强力的技术支持，国哥，帮我完成一系列的自动化运维推送脚本。 想想后来，我也会加上评论功能吧，现在的评论功能都太弱鸡了，必须要github账号，实在是不太好弄。 感谢您能抽出时间阅读我的博客。]]></content>
      <categories>
        <category>New Life</category>
      </categories>
      <tags>
        <tag>my life</tag>
      </tags>
  </entry>
</search>
